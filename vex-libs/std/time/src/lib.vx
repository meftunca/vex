// std/time lib - Vex wrapper around native high-performance vex_time C runtime
// v0.1.2 syntax (no ::, Go-style API surface adapted for Vex)

// Basic native types (outside extern)
type VexDuration = i64; // nanoseconds
struct VexInstant { unix_sec: i64, nsec: i32, _pad: i32 }
struct VexTime { wall: VexInstant, mono_ns: u64 }
type VexTz = *u8; // opaque timezone pointer

extern "C" {

	fn vt_now(out: *VexTime);
	fn vt_monotonic_now_ns(): u64;
	fn vt_instant_from_unix(sec: i64, nsec: i32): VexInstant;
	fn vt_instant_to_unix(t: VexInstant, sec: *i64, nsec: *i32);

	fn vt_parse_duration(s: *u8, out_ns: *VexDuration): i32;
	fn vt_format_duration(ns: VexDuration, buf: *u8, buflen: u64): i32;

	fn vt_add(t: VexTime, d: VexDuration): VexTime;
	fn vt_sub(t: VexTime, u: VexTime): VexDuration;
	fn vt_since(t: VexTime): VexDuration;
	fn vt_until(t: VexTime): VexDuration;

	fn vt_sleep_ns(ns: VexDuration): i32;

	fn vt_format_rfc3339_utc(t: VexInstant, buf: *u8, buflen: u64): i32;
	fn vt_parse_rfc3339(s: *u8, out: *VexInstant): i32;

	fn vt_tz_set_dir(path: *u8);
	fn vt_tz_utc(): VexTz;
	fn vt_tz_fixed(name: *u8, offset_sec: i32): VexTz;
	fn vt_tz_local(): VexTz;
	fn vt_tz_load(name: *u8): VexTz;
	fn vt_tz_load_from_memory(name: *u8, tzif: *u8, len: u64): VexTz;
	fn vt_tz_release(tz: VexTz);
	fn vt_tz_offset_at(tz: VexTz, utc: VexInstant, offset_sec: *i32, abbr: *u8): i32;
	fn vt_utc_to_tz(tz: VexTz, utc: VexInstant): VexInstant;

	fn vt_instant_date(t: VexInstant, year: *i32, month: *i32, day: *i32, hour: *i32, minute: *i32, second: *i32, nsec: *i32);
	fn vt_instant_clock(t: VexInstant, hour: *i32, minute: *i32, second: *i32);
	fn vt_instant_yearday(t: VexInstant): i32;
	fn vt_instant_weekday(t: VexInstant): i32; // 0=Sunday
	fn vt_instant_isoweek(t: VexInstant, iso_year: *i32): i32; // returns week

	fn vt_instant_compare(a: VexInstant, b: VexInstant): i32; // -1,0,1
	fn vt_instant_equal(a: VexInstant, b: VexInstant): i32;
	fn vt_instant_before(a: VexInstant, b: VexInstant): i32;
	fn vt_instant_after(a: VexInstant, b: VexInstant): i32;

	fn vt_instant_truncate(t: VexInstant, d: VexDuration): VexInstant;
	fn vt_instant_round(t: VexInstant, d: VexDuration): VexInstant;
	fn vt_instant_unix_milli(t: VexInstant): i64;
	fn vt_instant_unix_micro(t: VexInstant): i64;

	fn vt_format_go(utc: VexInstant, tz: VexTz, layout: *u8, out: *u8, outlen: u64): i32;
	fn vt_parse_go(layout: *u8, value: *u8, tz: VexTz, out: *VexInstant): i32;
}

// ==== High-level Vex types ====

export struct Duration { ns: i64 }
export struct Instant { inner: VexInstant }
export struct Time { inner: VexTime }
export struct Location { tz: VexTz }

// ==== Constructors & basics ====

export fn now(): Time {
	let t: VexTime = VexTime { wall: VexInstant { unix_sec: 0, nsec: 0, _pad: 0 }, mono_ns: 0 };
	vt_now(&t);
	return Time { inner: t };
}

export fn monotonic_now(): u64 { return vt_monotonic_now_ns(); }

export fn unix(sec: i64, nsec: i32): Instant {
	let inst = vt_instant_from_unix(sec, nsec);
	return Instant { inner: inst };
}

// ==== Instant: unix components ====
export fn unix_seconds(i: Instant): i64 { return i.inner.unix_sec; }
export fn unix_nanosecond(i: Instant): i32 { return i.inner.nsec; }

// ==== Duration parsing/formatting ====
export fn parse_duration(s: str): Result<Duration, str> {
	let raw: i64 = 0;
	let p: *u8 = s as *u8;
	let r = vt_parse_duration(p, &raw);
	if r == 0 { return Result.Ok(Duration { ns: raw }); } else { return Result.Err("invalid duration"); }
}

// Minimal formatting (allocate small stack buf, fallback if too small)
export fn format_duration(d: Duration): str {
	// TODO replace with proper dynamic string API when available
	return "Duration"; // placeholder
}

// ==== Arithmetic on Time ====
export fn add(t: Time, d: Duration): Time { return Time { inner: vt_add(t.inner, d.ns) }; }
export fn sub(t: Time, u: Time): Duration { return Duration { ns: vt_sub(t.inner, u.inner) }; }
export fn since(t: Time): Duration { return Duration { ns: vt_since(t.inner) }; }
export fn until(t: Time): Duration { return Duration { ns: vt_until(t.inner) }; }

// ==== Sleep ====
export fn sleep(d: Duration) { vt_sleep_ns(d.ns); }

// ==== RFC3339 ====
export fn format_rfc3339(i: Instant): str { return _format_rfc3339_impl(i); }
fn _format_rfc3339_impl(i: Instant): str {
	return "0001-01-01T00:00:00Z"; // placeholder until string builder ready
}

export fn parse_rfc3339(s: str): Result<Instant, str> {
	let inst: VexInstant = VexInstant { unix_sec: 0, nsec: 0, _pad: 0 };
	let p: *u8 = s as *u8;
	let r = vt_parse_rfc3339(p, &inst);
	if r == 0 { return Result.Ok(Instant { inner: inst }); } else { return Result.Err("invalid RFC3339"); }
}

// ==== Time Zones ====
export fn utc(): Location { return Location { tz: vt_tz_utc() }; }
export fn local(): Location { return Location { tz: vt_tz_local() }; }
export fn fixed_zone(name: str, offset_sec: i32): Location {
	let p: *u8 = name as *u8; return Location { tz: vt_tz_fixed(p, offset_sec) };
}
export fn load_location(name: str): Result<Location, str> {
	let p: *u8 = name as *u8; let tz = vt_tz_load(p); if tz != 0 as VexTz { return Result.Ok(Location { tz: tz }); } else { return Result.Err("tz not found"); }
}

// ==== Go layout formatting/parsing ====
export fn format_go(i: Instant, loc: Location, layout: str): Result<str, str> {
	// placeholder for future string builder
	return Result.Ok("formatted");
}

export fn parse_go(layout: str, value: str, loc: Location): Result<Instant, str> {
	let inst: VexInstant = VexInstant { unix_sec: 0, nsec: 0, _pad: 0 };
	let lp: *u8 = layout as *u8;
	let vp: *u8 = value as *u8;
	let r = vt_parse_go(lp, vp, loc.tz, &inst);
	if r == 0 { return Result.Ok(Instant { inner: inst }); } else { return Result.Err("invalid layout parse"); }
}

// ==== Component queries ====
// TODO: Tuple returns not yet supported - commented out
// export fn date(i: Instant): (i32, i32, i32) { ... }
// export fn clock(i: Instant): (i32, i32, i32) { ... }
// export fn iso_week(i: Instant): (i32, i32) { ... }

export fn weekday(i: Instant): i32 { return vt_instant_weekday(i.inner); }
export fn yearday(i: Instant): i32 { return vt_instant_yearday(i.inner); }

// ==== Comparison ====
export fn compare(a: Instant, b: Instant): i32 { return vt_instant_compare(a.inner, b.inner); }
export fn before(a: Instant, b: Instant): bool { return vt_instant_before(a.inner, b.inner) == 1; }
export fn after(a: Instant, b: Instant): bool { return vt_instant_after(a.inner, b.inner) == 1; }
export fn equal(a: Instant, b: Instant): bool { return vt_instant_equal(a.inner, b.inner) == 1; }

// ==== Truncate/Round ====
export fn truncate(i: Instant, d: Duration): Instant { return Instant { inner: vt_instant_truncate(i.inner, d.ns) }; }
export fn round(i: Instant, d: Duration): Instant { return Instant { inner: vt_instant_round(i.inner, d.ns) }; }

// ==== Unix helpers ====
export fn unix_milli(i: Instant): i64 { return vt_instant_unix_milli(i.inner); }
export fn unix_micro(i: Instant): i64 { return vt_instant_unix_micro(i.inner); }

// ==== Duration constants ====
export const NANOSECOND: i64 = 1;
export const MICROSECOND: i64 = 1000;
export const MILLISECOND: i64 = 1000000;
export const SECOND: i64 = 1000000000;
export const MINUTE: i64 = 60 * SECOND;
export const HOUR: i64 = 60 * MINUTE;

// ==== Simple smoke test (optional helper) ====
export fn _smoke_now(): bool {
	let t = now(); let dur = since(t); return dur.ns >= 0;
}

