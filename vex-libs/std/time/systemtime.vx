// std.time.SystemTime - Wall clock time
// Can go backwards if system clock is adjusted

import { libc } from "../ffi";
import { Duration, from_secs, from_nanos } from "./duration";

export struct SystemTime {
    secs: i64,   // Seconds since UNIX epoch
    nanos: i32,  // Nanosecond component
}

// UNIX epoch constant
export const UNIX_EPOCH: SystemTime = SystemTime {
    secs: 0,
    nanos: 0,
};

// Get current system time
export fn now():SystemTime {
    timestamp := libc.get_current_time();
    return SystemTime {
        secs: timestamp,
        nanos: 0,
    };
}

// Get current system time with nanosecond precision
export fn now_precise():(SystemTime | error) {
    // Allocate timespec
    ts := libc.safe_malloc(16)?; // sizeof(struct timespec)
    defer libc.safe_free(ts);
    
    libc.safe_clock_gettime(libc.CLOCK_REALTIME, ts as *libc.timespec)?;
    
    // Extract fields
    secs_ptr := ts as *i64;
    nanos_ptr := (ts as usize + 8) as *i64;
    
    secs := unsafe { *secs_ptr };
    nanos := unsafe { *nanos_ptr };
    
    return SystemTime {
        secs: secs,
        nanos: nanos as i32,
    };
}

// Duration since UNIX epoch
export fn duration_since_epoch(time: *SystemTime):Duration {
    total_nanos := time.secs * 1_000_000_000 + time.nanos as i64;
    return from_nanos(total_nanos);
}

// Duration since another time
export fn duration_since(later: *SystemTime, earlier: *SystemTime):(Duration | error) {
    later_total := later.secs * 1_000_000_000 + later.nanos as i64;
    earlier_total := earlier.secs * 1_000_000_000 + earlier.nanos as i64;
    
    diff := later_total - earlier_total;
    
    if diff < 0 {
        return error.new("SystemTime moved backwards");
    }
    
    return from_nanos(diff);
}

// Add duration
export fn add(time: SystemTime, duration: Duration):SystemTime {
    total_nanos := time.secs * 1_000_000_000 + time.nanos as i64 + duration.nanos;
    
    return SystemTime {
        secs: total_nanos / 1_000_000_000,
        nanos: (total_nanos % 1_000_000_000) as i32,
    };
}

// Subtract duration
export fn sub(time: SystemTime, duration: Duration):SystemTime {
    total_nanos := time.secs * 1_000_000_000 + time.nanos as i64 - duration.nanos;
    
    return SystemTime {
        secs: total_nanos / 1_000_000_000,
        nanos: (total_nanos % 1_000_000_000) as i32,
    };
}

// Comparison
export fn eq(a: *SystemTime, b: *SystemTime):bool {
    return a.secs == b.secs && a.nanos == b.nanos;
}

export fn lt(a: *SystemTime, b: *SystemTime):bool {
    if a.secs < b.secs {
        return true;
    }
    if a.secs == b.secs {
        return a.nanos < b.nanos;
    }
    return false;
}

export fn le(a: *SystemTime, b: *SystemTime):bool {
    return lt(a, b) || eq(a, b);
}

export fn gt(a: *SystemTime, b: *SystemTime):bool {
    return !le(a, b);
}

export fn ge(a: *SystemTime, b: *SystemTime):bool {
    return !lt(a, b);
}
