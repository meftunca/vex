// std.time.Duration - Represents a span of time
// Zero-cost wrapper around nanoseconds

export struct Duration {
    nanos: i64,  // Total nanoseconds
}

// Constants
export const NANOS_PER_SEC: i64 = 1_000_000_000;
export const NANOS_PER_MILLI: i64 = 1_000_000;
export const NANOS_PER_MICRO: i64 = 1_000;

// Constructors
export fn from_secs(secs: i64):Duration {
    return Duration { nanos: secs * NANOS_PER_SEC };
}

export fn from_millis(millis: i64):Duration {
    return Duration { nanos: millis * NANOS_PER_MILLI };
}

export fn from_micros(micros: i64):Duration {
    return Duration { nanos: micros * NANOS_PER_MICRO };
}

export fn from_nanos(nanos: i64):Duration {
    return Duration { nanos: nanos };
}

export fn zero():Duration {
    return Duration { nanos: 0 };
}

// Getters
export fn as_secs(d: *Duration):i64 {
    return d.nanos / NANOS_PER_SEC;
}

export fn as_millis(d: *Duration):i64 {
    return d.nanos / NANOS_PER_MILLI;
}

export fn as_micros(d: *Duration):i64 {
    return d.nanos / NANOS_PER_MICRO;
}

export fn as_nanos(d: *Duration):i64 {
    return d.nanos;
}

// Components
export fn subsec_nanos(d: *Duration):i32 {
    return (d.nanos % NANOS_PER_SEC) as i32;
}

export fn subsec_micros(d: *Duration):i32 {
    return (d.nanos / NANOS_PER_MICRO % 1_000_000) as i32;
}

export fn subsec_millis(d: *Duration):i32 {
    return (d.nanos / NANOS_PER_MILLI % 1_000) as i32;
}

// Arithmetic
export fn add(a: Duration, b: Duration):Duration {
    return Duration { nanos: a.nanos + b.nanos };
}

export fn sub(a: Duration, b: Duration):Duration {
    return Duration { nanos: a.nanos - b.nanos };
}

export fn mul(d: Duration, scalar: i64):Duration {
    return Duration { nanos: d.nanos * scalar };
}

export fn div(d: Duration, scalar: i64):Duration {
    return Duration { nanos: d.nanos / scalar };
}

// Comparison
export fn is_zero(d: *Duration):bool {
    return d.nanos == 0;
}

export fn eq(a: *Duration, b: *Duration):bool {
    return a.nanos == b.nanos;
}

export fn lt(a: *Duration, b: *Duration):bool {
    return a.nanos < b.nanos;
}

export fn le(a: *Duration, b: *Duration):bool {
    return a.nanos <= b.nanos;
}

export fn gt(a: *Duration, b: *Duration):bool {
    return a.nanos > b.nanos;
}

export fn ge(a: *Duration, b: *Duration):bool {
    return a.nanos >= b.nanos;
}
