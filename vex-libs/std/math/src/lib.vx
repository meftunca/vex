// Math Module - Clean, Generic-First Design
// Simplified using function overloading and consistent naming

import { sin, cos, tan, asin, acos, atan, atan2 } from "./native.vxc";
import { sinh, cosh, tanh, asinh, acosh, atanh } from "./native.vxc";
import { exp, exp2, log, log2, log10, pow, sqrt, cbrt } from "./native.vxc";
import { ceil, floor, round, trunc, fabs } from "./native.vxc";
import { hypot, fmod, copysign, fmax, fmin } from "./native.vxc";
import { isnan, isinf } from "./native.vxc";
import { erf, erfc, tgamma, lgamma } from "./native.vxc";
import { sinf, cosf, tanf, sqrtf, powf, fabsf, ceilf, floorf, roundf } from "./native.vxc";

type FLOAT_TYPES = f16 | f32 | f64;
type INTEGER_TYPES = i8 | i16 | i32 | i64 | u8 | u16 | u32 | u64;
type NUMERIC_TYPES = FLOAT_TYPES | INTEGER_TYPES;

export const PI: f64 = 3.14159265358979323846;
export const E: f64 = 2.71828182845904523536;
export const TAU: f64 = 6.28318530717958647693;
export const PHI: f64 = 1.61803398874989484820;
export const SQRT2: f64 = 1.41421356237309504880;

// ============================================================================
// ABSOLUTE VALUE - abs(x)
// ============================================================================
export fn abs(x: f64): f64 { return fabs(x); }
export fn abs(x: f32): f32 { return fabsf(x); }
export fn abs(x: i8): i8 { if x < 0 { return 0 - x; } return x; }
export fn abs(x: i16): i16 { if x < 0 { return 0 - x; } return x; }
export fn abs(x: i32): i32 { if x < 0 { return 0 - x; } return x; }
export fn abs(x: i64): i64 { if x < 0 { return 0 - x; } return x; }

// ============================================================================
// MIN/MAX - min(a, b) / max(a, b)
// ============================================================================
export fn min<T=NUMERIC_TYPES>(a: T, b: T): T { if a < b { return a; } return b; }
export fn max<T=NUMERIC_TYPES>(a: T, b: T): T { if a > b { return a; } return b; }
// export fn min(a: f32, b: f32): f32 { return fmin(a as f64, b as f64) as f32; }
// export fn max(a: f32, b: f32): f32 { return fmax(a as f64, b as f64) as f32; }
// export fn min(a: f64, b: f64): f64 { return fmin(a, b); }
// export fn max(a: f64, b: f64): f64 { return fmax(a, b); }

// ============================================================================
// CLAMP - clamp(x, min, max)
// ============================================================================
export fn clamp<T=NUMERIC_TYPES>(x: T, min_val: T, max_val: T): T {
    if x < min_val { return min_val; }
    if x > max_val { return max_val; }
    return x;
}

// ============================================================================
// SIGN - sign(x): returns -1, 0, or 1
// ============================================================================
export fn sign<T=INTEGER_TYPES>(x: T): T {
    if x > 0 { return 1; } elif x < 0 { return -1; } else { return 0; }
}
export fn sign<T=FLOAT_TYPES>(x: T): T {
    if x > 0.0 { return 1.0; } elif x < 0.0 { return -1.0; } else { return 0.0; }
}
// ============================================================================
// TRIGONOMETRY
// ============================================================================
export fn sin_f64(x: f64): f64 { return sin(x); }
export fn cos_f64(x: f64): f64 { return cos(x); }
export fn tan_f64(x: f64): f64 { return tan(x); }
export fn asin_f64(x: f64): f64 { return asin(x); }
export fn acos_f64(x: f64): f64 { return acos(x); }
export fn atan_f64(x: f64): f64 { return atan(x); }
export fn atan2_f64(y: f64, x: f64): f64 { return atan2(y, x); }
export fn sin_f32(x: f32): f32 { return sinf(x); }
export fn cos_f32(x: f32): f32 { return cosf(x); }
export fn tan_f32(x: f32): f32 { return tanf(x); }

// ============================================================================
// HYPERBOLIC
// ============================================================================
export fn sinh_f64(x: f64): f64 { return sinh(x); }
export fn cosh_f64(x: f64): f64 { return cosh(x); }
export fn tanh_f64(x: f64): f64 { return tanh(x); }
export fn asinh_f64(x: f64): f64 { return asinh(x); }
export fn acosh_f64(x: f64): f64 { return acosh(x); }
export fn atanh_f64(x: f64): f64 { return atanh(x); }

// ============================================================================
// EXPONENTIAL & LOGARITHMIC
// ============================================================================
export fn exp_f64(x: f64): f64 { return exp(x); }
export fn exp2_f64(x: f64): f64 { return exp2(x); }
export fn log_f64(x: f64): f64 { return log(x); }
export fn log2_f64(x: f64): f64 { return log2(x); }
export fn log10_f64(x: f64): f64 { return log10(x); }
export fn pow_f64(x: f64, y: f64): f64 { return pow(x, y); }
export fn sqrt_f64(x: f64): f64 { return sqrt(x); }
export fn cbrt_f64(x: f64): f64 { return cbrt(x); }
export fn sqrt_f32(x: f32): f32 { return sqrtf(x); }
export fn pow_f32(x: f32, y: f32): f32 { return powf(x, y); }

// ============================================================================
// ROUNDING
// ============================================================================
export fn ceil_f64(x: f64): f64 { return ceil(x); }
export fn floor_f64(x: f64): f64 { return floor(x); }
export fn round_f64(x: f64): f64 { return round(x); }
export fn trunc_f64(x: f64): f64 { return trunc(x); }
export fn ceil_f32(x: f32): f32 { return ceilf(x); }
export fn floor_f32(x: f32): f32 { return floorf(x); }
export fn round_f32(x: f32): f32 { return roundf(x); }

// ============================================================================
// CLASSIFICATION
// ============================================================================
export fn is_nan(x: f64): bool { return isnan(x) != 0; }
export fn is_inf(x: f64): bool { return isinf(x) != 0; }
export fn is_finite(x: f64): bool { 
    // isfinite is a macro, implement manually
    return !is_nan(x) && !is_inf(x);
}

// ============================================================================
// ADVANCED MATH
// ============================================================================
export fn hypot_f64(x: f64, y: f64): f64 { return hypot(x, y); }
export fn fmod_f64(x: f64, y: f64): f64 { return fmod(x, y); }
export fn copysign_f64(x: f64, y: f64): f64 { return copysign(x, y); }

export fn lerp(a: f64, b: f64, t: f64): f64 { return a + (b - a) * t; }
export fn lerp(a: f32, b: f32, t: f32): f32 { return a + (b - a) * t; }

export fn degrees(radians: f64): f64 { return radians * 180.0 / PI; }
export fn radians(degrees: f64): f64 { return degrees * PI / 180.0; }

// ============================================================================
// SPECIAL FUNCTIONS
// ============================================================================
export fn erf_f64(x: f64): f64 { return erf(x); }
export fn erfc_f64(x: f64): f64 { return erfc(x); }
export fn gamma_f64(x: f64): f64 { return tgamma(x); }
export fn lgamma_f64(x: f64): f64 { return lgamma(x); }

// ============================================================================
// INTEGER MATH
// ============================================================================

export fn gcd(a: i32, b: i32): i32 {
    let! x: i32 = a;
    if x < 0 {
        x = 0 - x;
    }
    let! y: i32 = b;
    if y < 0 {
        y = 0 - y;
    }
    while y != 0 {
        let temp: i32 = y;
        y = x % y;
        x = temp;
    }
    return x;
}

export fn gcd(a: i64, b: i64): i64 {
    let! x: i64 = a;
    if x < 0 {
        x = 0 - x;
    }
    let! y: i64 = b;
    if y < 0 {
        y = 0 - y;
    }
    while y != 0 {
        let temp: i64 = y;
        y = x % y;
        x = temp;
    }
    return x;
}

export fn lcm(a: i32, b: i32): i32 {
    if a == 0 || b == 0 { return 0; }
    let! product: i32 = a * b;
    if product < 0 {
        product = 0 - product;
    }
    return product / gcd(a, b);
}

export fn lcm(a: i64, b: i64): i64 {
    if a == 0 || b == 0 { return 0; }
    let! product: i64 = a * b;
    if product < 0 {
        product = 0 - product;
    }
    return product / gcd(a, b);
}

export fn factorial(n: i32): i64 {
    if n < 0 { return 0; }
    if n == 0 || n == 1 { return 1; }
    let! result: i64 = 1;
    let! i: i32 = 2;
    while i <= n {
        result = result * (i as i64);
        i = i + 1;
    }
    return result;
}

export fn pow_int(base: i32, exp: i32): i32 {
    if exp < 0 { return 0; }
    if exp == 0 { return 1; }
    let! result: i32 = 1;
    let! i: i32 = 0;
    while i < exp {
        result = result * base;
        i = i + 1;
    }
    return result;
}

export fn pow_int(base: i64, exp: i64): i64 {
    if exp < 0 { return 0; }
    if exp == 0 { return 1; }
    let! result: i64 = 1;
    let! i: i64 = 0;
    while i < exp {
        result = result * base;
        i = i + 1;
    }
    return result;
}