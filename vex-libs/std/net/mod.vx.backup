import { libc } from "../ffi";// std::net - Layer 2: Network Protocol (100% Safe Native Vex)

// This layer knows NOTHING about io_uring or unsafe code.

export struct TcpStream {// It only knows about "files" (sockets) from std::io.

    fd: i32,

    remote_addr: string,import { io } from "std";

    remote_port: u16,import type { Reader, Writer } from "std::io";

}

// TCP Stream - wraps a File (socket is a file in Unix)

export fn connect(host: string, port: u16): (TcpStream | error) {export struct TcpStream {

    sockfd := unsafe { libc.socket(libc.AF_INET, libc.SOCK_STREAM, 0) };    file: io.File,

    }

    if sockfd < 0 {

        return error.new("Failed to create socket");// Connect to a TCP server

    }// In real implementation, this would use socket() syscall via runtime

    // For now, we use a conceptual "/dev/tcp/host/port" path

    host_cstr := to_c_string(host);export async fn connect(host: string, port: i32) : (TcpStream | error) {

    defer libc.safe_free(host_cstr);    // Conceptual: open a socket as a file

        // Real implementation would call __runtime_socket_connect intrinsic

    addr := libc.safe_malloc(16)?;    socket_path := f"/dev/tcp/{host}/{port}";

    defer libc.safe_free(addr);    file := try await io.open(socket_path);

        

    unsafe {    return TcpStream { file: file };

        family_ptr := addr as *u16;}

        *family_ptr = libc.AF_INET as u16;

        // Implement Reader trait for TcpStream

        port_ptr := (addr as usize + 2) as *u16;// This just delegates to the underlying File

        *port_ptr = htons(port);export fn (s: &TcpStream) read(buf: &[byte]) : (i32 | error) {

            return await s.file.read(buf);

        ip_result := libc.inet_pton(libc.AF_INET, host_cstr, (addr as usize + 4) as *byte);}

        if ip_result <= 0 {

            libc.close(sockfd);// Implement Writer trait for TcpStream

            return error.new("Invalid IP address");// This just delegates to the underlying File

        }export fn (s: &TcpStream) write(buf: &[byte]) : (i32 | error) {

    }    return await s.file.write(buf);

    }

    result := unsafe { libc.connect(sockfd, addr as *libc.sockaddr, 16) };

    // Close the connection

    if result < 0 {export fn (s: &TcpStream) close() : (nil | error) {

        unsafe { libc.close(sockfd); }    return await s.file.close();

        return error.new("Failed to connect");}

    }

    // UDP Socket

    return TcpStream {export struct UdpSocket {

        fd: sockfd,    file: io.File,

        remote_addr: host,}

        remote_port: port,

    };// Bind to a UDP port

}export async fn bind_udp(addr: string, port: i32) : (UdpSocket | error) {

    socket_path := f"/dev/udp/{addr}/{port}";

export fn (stream: &TcpStream) read(buffer: *byte, size: usize): (i64 | error) {    file := try await io.open(socket_path);

    bytes_read := unsafe { libc.read(stream.fd, buffer, size) };    

        return UdpSocket { file: file };

    if bytes_read < 0 {}

        return error.new("Failed to read from socket");

    }// Send UDP packet

    export fn (s: &UdpSocket) send_to(buf: &[byte], dest: string) : (i32 | error) {

    return bytes_read;    // In real implementation, this would use sendto() syscall

}    return await s.file.write(buf);

}

export fn (stream: &TcpStream) write(data: *byte, size: usize): (i64 | error) {

    bytes_written := unsafe { libc.write(stream.fd, data, size) };// Receive UDP packet

    export fn (s: &UdpSocket) recv_from(buf: &[byte]) : (i32 | error) {

    if bytes_written < 0 {    // In real implementation, this would use recvfrom() syscall

        return error.new("Failed to write to socket");    return await s.file.read(buf);

    }}

    

    return bytes_written;// TCP Listener for server-side

}export struct TcpListener {

    file: io.File,

export fn (stream: &TcpStream) close(): (bool | error) {}

    result := unsafe { libc.close(stream.fd) };

    // Listen on a TCP port

    if result != 0 {export async fn listen(addr: string, port: i32) : (TcpListener | error) {

        return error.new("Failed to close socket");    listen_path := f"/dev/tcp/listen/{addr}/{port}";

    }    file := try await io.open(listen_path);

        

    return true;    return TcpListener { file: file };

}}



export struct TcpListener {// Accept incoming connection

    fd: i32,export fn (l: &TcpListener) accept() : (TcpStream | error) {

    local_addr: string,    // In real implementation, this would use accept() syscall

    local_port: u16,    // For now, conceptual placeholder

}    client_file := l.file; // Placeholder

    return TcpStream { file: client_file };

export fn listen(addr: string, port: u16): (TcpListener | error) {}

    sockfd := unsafe { libc.socket(libc.AF_INET, libc.SOCK_STREAM, 0) };
    
    if sockfd < 0 {
        return error.new("Failed to create socket");
    }
    
    opt: i32 = 1;
    unsafe {
        libc.setsockopt(sockfd, libc.SOL_SOCKET, libc.SO_REUSEADDR, &opt as *byte, 4);
    }
    
    addr_cstr := to_c_string(addr);
    defer libc.safe_free(addr_cstr);
    
    server_addr := libc.safe_malloc(16)?;
    defer libc.safe_free(server_addr);
    
    unsafe {
        family_ptr := server_addr as *u16;
        *family_ptr = libc.AF_INET as u16;
        
        port_ptr := (server_addr as usize + 2) as *u16;
        *port_ptr = htons(port);
        
        if addr == "0.0.0.0" || addr == "" {
            ip_ptr := (server_addr as usize + 4) as *u32;
            *ip_ptr = 0;
        } else {
            libc.inet_pton(libc.AF_INET, addr_cstr, (server_addr as usize + 4) as *byte);
        }
    }
    
    bind_result := unsafe { libc.bind(sockfd, server_addr as *libc.sockaddr, 16) };
    
    if bind_result < 0 {
        unsafe { libc.close(sockfd); }
        return error.new("Failed to bind socket");
    }
    
    listen_result := unsafe { libc.listen(sockfd, 128) };
    
    if listen_result < 0 {
        unsafe { libc.close(sockfd); }
        return error.new("Failed to listen on socket");
    }
    
    return TcpListener {
        fd: sockfd,
        local_addr: addr,
        local_port: port,
    };
}

export fn (listener: &TcpListener) accept(): (TcpStream | error) {
    client_addr := libc.safe_malloc(16)?;
    defer libc.safe_free(client_addr);
    
    client_len: u32 = 16;
    
    client_fd := unsafe { libc.accept(listener.fd, client_addr as *libc.sockaddr, &client_len) };
    
    if client_fd < 0 {
        return error.new("Failed to accept connection");
    }
    
    return TcpStream {
        fd: client_fd,
        remote_addr: "unknown",
        remote_port: 0,
    };
}

export fn (listener: &TcpListener) close(): (bool | error) {
    result := unsafe { libc.close(listener.fd) };
    
    if result != 0 {
        return error.new("Failed to close listener");
    }
    
    return true;
}

export struct UdpSocket {
    fd: i32,
    local_addr: string,
    local_port: u16,
}

export fn bind_udp(addr: string, port: u16): (UdpSocket | error) {
    sockfd := unsafe { libc.socket(libc.AF_INET, libc.SOCK_DGRAM, 0) };
    
    if sockfd < 0 {
        return error.new("Failed to create UDP socket");
    }
    
    addr_cstr := to_c_string(addr);
    defer libc.safe_free(addr_cstr);
    
    server_addr := libc.safe_malloc(16)?;
    defer libc.safe_free(server_addr);
    
    unsafe {
        family_ptr := server_addr as *u16;
        *family_ptr = libc.AF_INET as u16;
        
        port_ptr := (server_addr as usize + 2) as *u16;
        *port_ptr = htons(port);
        
        if addr == "0.0.0.0" || addr == "" {
            ip_ptr := (server_addr as usize + 4) as *u32;
            *ip_ptr = 0;
        } else {
            libc.inet_pton(libc.AF_INET, addr_cstr, (server_addr as usize + 4) as *byte);
        }
    }
    
    bind_result := unsafe { libc.bind(sockfd, server_addr as *libc.sockaddr, 16) };
    
    if bind_result < 0 {
        unsafe { libc.close(sockfd); }
        return error.new("Failed to bind UDP socket");
    }
    
    return UdpSocket {
        fd: sockfd,
        local_addr: addr,
        local_port: port,
    };
}

export fn (socket: &UdpSocket) recv_from(buffer: *byte, size: usize): (i64, string, u16 | error) {
    from_addr := libc.safe_malloc(16)?;
    defer libc.safe_free(from_addr);
    
    from_len: u32 = 16;
    
    bytes := unsafe { 
        libc.recvfrom(socket.fd, buffer, size, 0, from_addr as *libc.sockaddr, &from_len) 
    };
    
    if bytes < 0 {
        return error.new("Failed to receive UDP packet");
    }
    
    return (bytes, "unknown", 0);
}

export fn (socket: &UdpSocket) send_to(data: *byte, size: usize, addr: string, port: u16): (i64 | error) {
    addr_cstr := to_c_string(addr);
    defer libc.safe_free(addr_cstr);
    
    dest_addr := libc.safe_malloc(16)?;
    defer libc.safe_free(dest_addr);
    
    unsafe {
        family_ptr := dest_addr as *u16;
        *family_ptr = libc.AF_INET as u16;
        
        port_ptr := (dest_addr as usize + 2) as *u16;
        *port_ptr = htons(port);
        
        libc.inet_pton(libc.AF_INET, addr_cstr, (dest_addr as usize + 4) as *byte);
    }
    
    bytes := unsafe {
        libc.sendto(socket.fd, data, size, 0, dest_addr as *libc.sockaddr, 16)
    };
    
    if bytes < 0 {
        return error.new("Failed to send UDP packet");
    }
    
    return bytes;
}

export fn (socket: &UdpSocket) close(): (bool | error) {
    result := unsafe { libc.close(socket.fd) };
    
    if result != 0 {
        return error.new("Failed to close UDP socket");
    }
    
    return true;
}

fn htons(port: u16): u16 {
    return ((port & 0xFF) << 8) | ((port >> 8) & 0xFF);
}

fn to_c_string(s: string): *byte {
    len := s.len();
    ptr_result := libc.safe_malloc(len + 1);
    
    match ptr_result {
        ptr: *byte => {
            src := s.as_ptr();
            unsafe { libc.memcpy(ptr, src, len); }
            unsafe { *(ptr + len) = 0; }
            return ptr;
        },
        err: error => {
            return 0 as *byte;
        },
    }
}
