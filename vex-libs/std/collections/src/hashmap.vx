// HashMap<K, V> - Generic hash map
// Zero-cost wrapper over vex_swisstable_v2.c (30M+ ops/s)

// External C functions from vex_swisstable_v2.c
extern "C" {
    fn vex_map_new_v2(map: **void, capacity: i64): bool;
    fn vex_map_insert_v2(map: *void, key: str, value: *void): bool;
    fn vex_map_get_v2(map: *void, key: str): *void;
    fn vex_map_remove_v2(map: *void, key: str): bool;
    fn vex_map_len_v2(map: *void): i64;
    fn vex_map_free_v2(map: *void);
}

// HashMap<K, V> - Generic hash map
export struct HashMap<K, V> {
    inner: *void,     // Opaque pointer to C SwissMap
    len: i64,         // Cached length
    capacity: i64,    // Current capacity
}

// Free functions for HashMap construction
export fn new_hashmap<K, V>(): HashMap<K, V> {
    return with_capacity_hashmap<K, V>(16);
}

export fn with_capacity_hashmap<K, V>(cap: i64): HashMap<K, V> {
    let! map = HashMap<K, V> {
        inner: 0 as *void,
        len: 0,
        capacity: cap,
    };
    
    // Allocate C map
    vex_map_new_v2(&map.inner, cap);
    
    return map;
}

// Concrete constructors for common types (temporary workaround)
export fn new_hashmap_str_i32(): HashMap<str, i32> {
    return with_capacity_hashmap(16);
}

export fn new_hashmap_i32_i32(): HashMap<i32, i32> {
    return with_capacity_hashmap(16);
}

export fn with_capacity_hashmap_str_i32(cap: i64): HashMap<str, i32> {
    return with_capacity_hashmap(cap);
}

export fn with_capacity_hashmap_i32_i32(cap: i64): HashMap<i32, i32> {
    return with_capacity_hashmap(cap);
}

// HashMap methods using Golang-style syntax
fn (self: &HashMap<K, V>!) insert(key: K, value: V): Option<V> {
    // For now, use simple string conversion
    // TODO: Proper hash function for generic K
    let key_str = "key";  // Placeholder
    
    // Check if key exists (for return value)
    let old_ptr = vex_map_get_v2(self.inner, key_str);
    if old_ptr == (0 as *void) {
        let old_val = None;
        // Insert/update
        let inserted = vex_map_insert_v2(self.inner, key_str, &value as *void);
        if inserted {
            self.len = self.len + 1;
        }
        return old_val;
    } else {
        let old = *(old_ptr as *V);
        let old_val = Some(old);
        // Insert/update
        vex_map_insert_v2(self.inner, key_str, &value as *void);
        return old_val;
    }
}

// Get value by key
fn (self: &HashMap<K, V>) get(key: K): Option<V> {
    let key_str = "key";  // Placeholder
    let ptr = vex_map_get_v2(self.inner, key_str);
    
    if ptr == (0 as *void) {
        return None;
    } else {
        let val = *(ptr as *V);
        return Some(val);
    }
}

// Remove key-value pair
fn (self: &HashMap<K, V>!) remove(key: K): Option<V> {
    let key_str = "key";  // Placeholder
    
    // Get old value before removing
    let ptr = vex_map_get_v2(self.inner, key_str);
    if ptr == (0 as *void) {
        return None;
    }
    
    let old = *(ptr as *V);
    let old_val = Some(old);
    
    // Remove from map
    let removed = vex_map_remove_v2(self.inner, key_str);
    
    if removed {
        self.len = self.len - 1;
    }
    
    return old_val;
}

// Check if key exists
fn (self: &HashMap<K, V>) contains_key(key: K): bool {
        return match self.get(key) {
            Option.Some(_) => true,
            Option.None => false,
        };
    }

// Get number of entries
fn (self: &HashMap<K, V>) len(): i64 {
        return self.len;
    }

// Check if empty
fn (self: &HashMap<K, V>) is_empty(): bool {
        return self.len == 0;
    }

// Clear all entries
fn (self: &HashMap<K, V>!) clear() {
    vex_map_free_v2(self.inner);
    vex_map_new_v2(&self.inner, self.capacity);
    self.len = 0;
}
