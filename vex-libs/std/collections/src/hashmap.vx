//zero-cost wrapper over vex_swisstable_v2.c (30M+ ops/s)

// External C functions from vex_swisstable_v2.c
import {
    vex_map_new_v2,
    vex_map_insert_v2,
    vex_map_get_v2,
    vex_map_remove_v2,
    vex_map_len_v2,
    vex_map_free_v2
} from "./native.vxc";

    

contract HashMapContract<K, V> {
    insert(key: K, value: V): Option<V>;
    get(key: K): Option<V>;
    remove(key: K): Option<V> ;
    contains_key(key: K): bool ;
    len(): i64 ;
    is_empty(): bool ;
    clear() ;
}
// HashMap<K, V> - Generic hash map
export struct HashMap<K, V> impl HashMapContract<K, V> {
    inner: *u8,     // Opaque pointer to C SwissMap
    len: i64,         // Cached length
    capacity: i64,    // Current capacity
}

// ‚≠ê Static constructor - enables HashMap<str, i32>() syntax
// These are FREE FUNCTIONS, not methods (no receiver = static)
export fn HashMap.new<K, V>(): HashMap<K, V> {
    return with_capacity_hashmap<K, V>(16);
}

export fn HashMap.new<K, V>(cap: i64): HashMap<K, V> {
    return with_capacity_hashmap<K, V>(cap);
}
    
// Free functions for HashMap construction
export fn new_hashmap<K, V>(): HashMap<K, V> {
    return with_capacity_hashmap<K, V>(16);
}

export fn with_capacity_hashmap<K, V>(cap: i64): HashMap<K, V> {
    let! map = HashMap<K, V> {
        inner: 0 as *u8,
        len: 0,
        capacity: cap,
    };
    
    // Allocate C map
    vex_map_new_v2(&map.inner, cap);
    
    return map;
}



// HashMap methods using Golang-style syntax
fn (self: &HashMap<K, V>!) insert(key: K, value: V): Option<V> {
    // For now, use simple string conversion
    // TODO: Proper hash function for generic K
    let! key_str = "key";  // Placeholder
    
    // Check if key exists (for return value)
    let old_ptr = vex_map_get_v2(self.inner, key_str);
    if old_ptr == (0 as *u8) {
        let old_val = None;
        // Insert/update
        let inserted = vex_map_insert_v2(self.inner, key_str, &value as *u8);
        if inserted {
            self.len = self.len + 1;
        }
        return old_val;
    } else {
        let old = *(old_ptr as *V);
        let old_val = Some(old);
        // Insert/update
        vex_map_insert_v2(self.inner, key_str, &value as *u8);
        return old_val;
    }
}

// Get value by key
fn (self: &HashMap<K, V>) get(key: K): Option<V> {
    let key_str = "key";  // Placeholder
    let ptr = vex_map_get_v2(self.inner, key_str);
    
    if ptr == (0 as *u8) {
        return None;
    } else {
        let val = *(ptr as *V);
        return Some(val);
    }
}

// Remove key-value pair
fn (self: &HashMap<K, V>!) remove(key: K): Option<V> {
    let key_str = "key";  // Placeholder
    
    // Get old value before removing
    let ptr = vex_map_get_v2(self.inner, key_str);
    if ptr == (0 as *u8) {
        return None;
    }
    
    let old = *(ptr as *V);
    let old_val = Some(old);
    
    // Remove from map
    let removed = vex_map_remove_v2(self.inner, key_str);
    
    if removed {
        self.len = self.len - 1;
    }
    
    return old_val;
}

// Check if key exists
fn (self: &HashMap<K, V>) contains_key(key: K): bool {
        return match self.get(key) {
            Option.Some(_) => true,
            Option.None => false,
        };
    }

// Get number of entries
fn (self: &HashMap<K, V>) len(): i64 {
        return self.len;
    }

// Check if empty
fn (self: &HashMap<K, V>) is_empty(): bool {
        return self.len == 0;
    }

// Clear all entries
fn (self: &HashMap<K, V>!) clear() {
    vex_map_free_v2(self.inner);
    vex_map_new_v2(&self.inner, self.capacity);
    self.len = 0;
}
