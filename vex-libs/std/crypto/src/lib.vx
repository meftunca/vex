// Crypto Module - OpenSSL FFI bindings
// All 36 C functions from vex-runtime/c/vex_openssl/

const VEX_TLS_OK: i32 = 0;
const VEX_TLS_WANT_READ: i32 = 1;
const VEX_TLS_WANT_WRITE: i32 = 2;
const VEX_TLS_ERR: i32 = -1;

struct VexTlsCtx {}
struct VexTlsConn {}
struct VexTlsConfig {
    is_server: i32,
    verify_peer: i32,
    ca_bundle_path: *u8,
    server_name: *u8,
    alpn_csv: *u8,
    cert_pem: *u8,
    key_pem: *u8,
}

struct VexX509Info {
    subject: [u8; 256],
    issuer: [u8; 256],
    serial: [u8; 64],
    not_before: i64,
    not_after: i64,
    is_ca: i32,
    key_usage: i32,
}

extern "C" {
    fn vex_crypto_last_error(): *u8;
    fn vex_aead_seal(aead_name: *const u8, key: *const u8, key_len: u64, nonce: *const u8, nonce_len: u64, ad: *const u8, ad_len: u64, plaintext: *const u8, pt_len: u64, out_cipher: *u8, inout_ct_len: *u64, tag_len: u64): i32;
    fn vex_aead_open(aead_name: *const u8, key: *const u8, key_len: u64, nonce: *const u8, nonce_len: u64, ad: *const u8, ad_len: u64, ciphertext: *const u8, ct_len: u64, out_plain: *u8, inout_pt_len: *u64, tag_len: u64): i32;
    fn vex_hash(algo: *const u8, msg: *const u8, len: u64, out_digest: *u8, inout_len: *u64): i32;
    fn vex_hkdf(algo: *const u8, ikm: *const u8, ikm_len: u64, salt: *const u8, salt_len: u64, info: *const u8, info_len: u64, out_okm: *u8, okm_len: u64): i32;
    fn vex_x25519_public_from_private(pub: *u8, priv: *const u8): i32;
    fn vex_x25519(shared: *u8, priv: *const u8, peer_pub: *const u8): i32;
    fn vex_ed25519_sign(sig: *u8, msg: *const u8, len: u64, sk: *const u8): i32;
    fn vex_ed25519_verify(sig: *const u8, msg: *const u8, len: u64, pk: *const u8): i32;
    fn vex_rsa_generate_keypair(bits: i32, out_public_der: *u8, pub_len: *u64, out_private_der: *u8, priv_len: *u64): i32;
    fn vex_rsa_sign(hash_algo: *const u8, msg: *const u8, msg_len: u64, private_key_der: *const u8, priv_len: u64, out_sig: *u8, sig_len: *u64): i32;
    fn vex_rsa_verify(hash_algo: *const u8, msg: *const u8, msg_len: u64, sig: *const u8, sig_len: u64, public_key_der: *const u8, pub_len: u64): i32;
    fn vex_rsa_encrypt(plaintext: *const u8, pt_len: u64, public_key_der: *const u8, pub_len: u64, out_cipher: *u8, ct_len: *u64): i32;
    fn vex_rsa_decrypt(ciphertext: *const u8, ct_len: u64, private_key_der: *const u8, priv_len: u64, out_plain: *u8, pt_len: *u64): i32;
    fn vex_ecdsa_generate_keypair(curve: *const u8, out_public_der: *u8, pub_len: *u64, out_private_der: *u8, priv_len: *u64): i32;
    fn vex_ecdsa_sign(curve: *const u8, hash_algo: *const u8, msg: *const u8, msg_len: u64, private_key_der: *const u8, priv_len: u64, out_sig: *u8, sig_len: *u64): i32;
    fn vex_ecdsa_verify(curve: *const u8, hash_algo: *const u8, msg: *const u8, msg_len: u64, sig: *const u8, sig_len: u64, public_key_der: *const u8, pub_len: u64): i32;
    fn vex_ecdh(curve: *const u8, private_key_der: *const u8, priv_len: u64, peer_public_der: *const u8, peer_len: u64, out_shared: *u8, shared_len: *u64): i32;
    fn vex_pem_to_der(pem: *const u8, pem_len: u64, out_der: *u8, der_len: *u64): i32;
    fn vex_der_to_pem(label: *const u8, der: *const u8, der_len: u64, out_pem: *u8, pem_len: *u64): i32;
    fn vex_crypto_free(ptr: *u8);
    fn vex_cipher_encrypt(cipher_name: *const u8, key: *const u8, key_len: u64, iv: *const u8, iv_len: u64, plaintext: *const u8, pt_len: u64, out_cipher: *u8, out_ct_len: *u64): i32;
    fn vex_cipher_decrypt(cipher_name: *const u8, key: *const u8, key_len: u64, iv: *const u8, iv_len: u64, ciphertext: *const u8, ct_len: u64, out_plain: *u8, out_pt_len: *u64): i32;
    fn vex_hmac(algo: *const u8, key: *const u8, key_len: u64, msg: *const u8, msg_len: u64, out_mac: *u8, out_mac_len: *u64): i32;
    fn vex_pbkdf2(algo: *const u8, password: *const u8, pw_len: u64, salt: *const u8, salt_len: u64, iterations: i32, out_key: *u8, key_len: u64): i32;
    fn vex_random_bytes(buf: *u8, len: u64): i32;
    fn vex_tls_ctx_create(cfg: *VexTlsConfig): *VexTlsCtx;
    fn vex_tls_ctx_destroy(ctx: *VexTlsCtx);
    fn vex_tls_conn_wrap_fd(ctx: *VexTlsCtx, fd: i32): *VexTlsConn;
    fn vex_tls_conn_destroy(c: *VexTlsConn);
    fn vex_tls_handshake(c: *VexTlsConn): i32;
    fn vex_tls_read(c: *VexTlsConn, buf: *u8, cap: u64, out_n: *u64): i32;
    fn vex_tls_write(c: *VexTlsConn, buf: *const u8, len: u64, out_n: *u64): i32;
    fn vex_tls_shutdown(c: *VexTlsConn): i32;
    fn vex_tls_get_fd(c: *VexTlsConn): i32;
    fn vex_tls_last_error(): *u8;
    fn vex_x509_parse(cert_der: *const u8, cert_len: u64, info: *VexX509Info): i32;
    fn vex_x509_verify_chain(cert_der: *const u8, cert_len: u64, ca_certs_pem: *const u8, ca_len: u64): i32;
    fn vex_x509_generate_self_signed(subject: *const u8, days_valid: i32, out_cert_pem: *u8, cert_len: *u64, out_key_pem: *u8, key_len: *u64): i32;
    fn vex_x509_generate_csr(subject: *const u8, private_key_pem: *const u8, key_len: u64, out_csr_pem: *u8, csr_len: *u64): i32;
}
