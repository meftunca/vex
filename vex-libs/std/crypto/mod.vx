// std::crypto - Cryptographic utilities (High-level)
// Wrappers around OpenSSL/LibreSSL

import { openssl } from "../ffi";

// ============================================================================
// Hash Functions
// ============================================================================

// SHA-256 hash
export fn sha256(data: &[byte]):[byte; 32] {
    hash := [byte; 32];
    
    unsafe {
        openssl.SHA256(
            data.as_ptr(),
            data.len() as u64,
            hash.as_mut_ptr()
        );
    }
    
    return hash;
}

// SHA-512 hash
export fn sha512(data: &[byte]):[byte; 64] {
    hash := [byte; 64];
    
    unsafe {
        openssl.SHA512(
            data.as_ptr(),
            data.len() as u64,
            hash.as_mut_ptr()
        );
    }
    
    return hash;
}

// MD5 hash (deprecated, use only for compatibility)
export fn md5(data: &[byte]):[byte; 16] {
    hash := [byte; 16];
    
    unsafe {
        openssl.MD5(
            data.as_ptr(),
            data.len() as u64,
            hash.as_mut_ptr()
        );
    }
    
    return hash;
}

// SHA-1 hash (deprecated, use only for compatibility)
export fn sha1(data: &[byte]):[byte; 20] {
    hash := [byte; 20];
    
    unsafe {
        openssl.SHA1(
            data.as_ptr(),
            data.len() as u64,
            hash.as_mut_ptr()
        );
    }
    
    return hash;
}

// ============================================================================
// HMAC (Hash-based Message Authentication Code)
// ============================================================================

// HMAC-SHA256
export fn hmac_sha256(key: &[byte], data: &[byte]):[byte; 32] {
    hmac := [byte; 32];
    let mut len: u32 = 32;
    
    unsafe {
        openssl.HMAC(
            openssl.EVP_sha256(),
            key.as_ptr() as *byte,
            key.len() as i32,
            data.as_ptr(),
            data.len() as u64,
            hmac.as_mut_ptr(),
            &len
        );
    }
    
    return hmac;
}

// HMAC-SHA512
export fn hmac_sha512(key: &[byte], data: &[byte]):[byte; 64] {
    hmac := [byte; 64];
    let mut len: u32 = 64;
    
    unsafe {
        openssl.HMAC(
            openssl.EVP_sha512(),
            key.as_ptr() as *byte,
            key.len() as i32,
            data.as_ptr(),
            data.len() as u64,
            hmac.as_mut_ptr(),
            &len
        );
    }
    
    return hmac;
}

// ============================================================================
// Secure Random Number Generation
// ============================================================================

// Generate random bytes
export fn random_bytes(count: usize):[byte] {
    bytes := make([byte], count);
    
    result := unsafe {
        openssl.RAND_bytes(bytes.as_mut_ptr(), count as i32)
    };
    
    if result != 1 {
        // Fallback: use system random (less secure)
        // TODO: Better error handling
    }
    
    return bytes;
}

// Generate random u32
export fn random_u32():u32 {
    bytes := random_bytes(4);
    return (bytes[0] as u32) | ((bytes[1] as u32) << 8) | 
           ((bytes[2] as u32) << 16) | ((bytes[3] as u32) << 24);
}

// Generate random u64
export fn random_u64():u64 {
    bytes := random_bytes(8);
    return (bytes[0] as u64) | ((bytes[1] as u64) << 8) | 
           ((bytes[2] as u64) << 16) | ((bytes[3] as u64) << 24) |
           ((bytes[4] as u64) << 32) | ((bytes[5] as u64) << 40) |
           ((bytes[6] as u64) << 48) | ((bytes[7] as u64) << 56);
}

// Generate random i32 in range [min, max)
export fn random_range(min: i32, max: i32):i32 {
    range := (max - min) as u32;
    random := random_u32();
    return min + (random % range) as i32;
}

// ============================================================================
// AES Encryption/Decryption
// ============================================================================

// AES-256-CBC encryption
export fn aes_256_cbc_encrypt(key: &[byte; 32], iv: &[byte; 16], plaintext: &[byte]):([byte] | error) {
    if key.len() != 32 {
        return error.new("Key must be 32 bytes for AES-256");
    }
    if iv.len() != 16 {
        return error.new("IV must be 16 bytes");
    }
    
    // Allocate output buffer (plaintext + padding)
    max_output_len := plaintext.len() + 16;
    ciphertext := make([byte], max_output_len);
    let mut len: i32 = 0;
    let mut final_len: i32 = 0;
    
    // Create and initialize cipher context
    ctx := unsafe { openssl.EVP_CIPHER_CTX_new() };
    if ctx == 0 as *openssl.EVP_CIPHER_CTX {
        return error.new("Failed to create cipher context");
    }
    
    // Initialize encryption
    init_result := unsafe {
        openssl.EVP_EncryptInit_ex(
            ctx,
            openssl.EVP_aes_256_cbc(),
            0 as *openssl.ENGINE,
            key.as_ptr(),
            iv.as_ptr()
        )
    };
    
    if init_result != 1 {
        unsafe { openssl.EVP_CIPHER_CTX_free(ctx); }
        return error.new("Failed to initialize encryption");
    }
    
    // Encrypt
    update_result := unsafe {
        openssl.EVP_EncryptUpdate(
            ctx,
            ciphertext.as_mut_ptr(),
            &len,
            plaintext.as_ptr(),
            plaintext.len() as i32
        )
    };
    
    if update_result != 1 {
        unsafe { openssl.EVP_CIPHER_CTX_free(ctx); }
        return error.new("Encryption failed");
    }
    
    // Finalize (add padding)
    final_result := unsafe {
        openssl.EVP_EncryptFinal_ex(
            ctx,
            &ciphertext[len as usize],
            &final_len
        )
    };
    
    unsafe { openssl.EVP_CIPHER_CTX_free(ctx); }
    
    if final_result != 1 {
        return error.new("Encryption finalization failed");
    }
    
    total_len := (len + final_len) as usize;
    ciphertext.resize(total_len);
    return ciphertext;
}

// AES-256-CBC decryption
export fn aes_256_cbc_decrypt(key: &[byte; 32], iv: &[byte; 16], ciphertext: &[byte]):([byte] | error) {
    if key.len() != 32 {
        return error.new("Key must be 32 bytes for AES-256");
    }
    if iv.len() != 16 {
        return error.new("IV must be 16 bytes");
    }
    
    // Allocate output buffer
    max_output_len := ciphertext.len();
    plaintext := make([byte], max_output_len);
    let mut len: i32 = 0;
    let mut final_len: i32 = 0;
    
    // Create and initialize cipher context
    ctx := unsafe { openssl.EVP_CIPHER_CTX_new() };
    if ctx == 0 as *openssl.EVP_CIPHER_CTX {
        return error.new("Failed to create cipher context");
    }
    
    // Initialize decryption
    init_result := unsafe {
        openssl.EVP_DecryptInit_ex(
            ctx,
            openssl.EVP_aes_256_cbc(),
            0 as *openssl.ENGINE,
            key.as_ptr(),
            iv.as_ptr()
        )
    };
    
    if init_result != 1 {
        unsafe { openssl.EVP_CIPHER_CTX_free(ctx); }
        return error.new("Failed to initialize decryption");
    }
    
    // Decrypt
    update_result := unsafe {
        openssl.EVP_DecryptUpdate(
            ctx,
            plaintext.as_mut_ptr(),
            &len,
            ciphertext.as_ptr(),
            ciphertext.len() as i32
        )
    };
    
    if update_result != 1 {
        unsafe { openssl.EVP_CIPHER_CTX_free(ctx); }
        return error.new("Decryption failed");
    }
    
    // Finalize (remove padding)
    final_result := unsafe {
        openssl.EVP_DecryptFinal_ex(
            ctx,
            &plaintext[len as usize],
            &final_len
        )
    };
    
    unsafe { openssl.EVP_CIPHER_CTX_free(ctx); }
    
    if final_result != 1 {
        return error.new("Decryption finalization failed (bad padding?)");
    }
    
    total_len := (len + final_len) as usize;
    plaintext.resize(total_len);
    return plaintext;
}

// ============================================================================
// Password Hashing (PBKDF2)
// ============================================================================

// PBKDF2 with SHA-256
export fn pbkdf2_sha256(password: &[byte], salt: &[byte], iterations: i32, key_len: usize):[byte] {
    derived_key := make([byte], key_len);
    
    result := unsafe {
        openssl.PKCS5_PBKDF2_HMAC(
            password.as_ptr() as *byte,
            password.len() as i32,
            salt.as_ptr(),
            salt.len() as i32,
            iterations,
            openssl.EVP_sha256(),
            key_len as i32,
            derived_key.as_mut_ptr()
        )
    };
    
    if result != 1 {
        // Return empty array on error
        // TODO: Better error handling
    }
    
    return derived_key;
}

// ============================================================================
// Constant-time Comparison (prevents timing attacks)
// ============================================================================

// Compare two byte arrays in constant time
export fn constant_time_compare(a: &[byte], b: &[byte]):bool {
    if a.len() != b.len() {
        return false;
    }
    
    result := unsafe {
        openssl.CRYPTO_memcmp(
            a.as_ptr() as *byte,
            b.as_ptr() as *byte,
            a.len() as u64
        )
    };
    
    return result == 0;
}

// ============================================================================
// Convenience Functions
// ============================================================================

// Generate AES key from password
export fn derive_aes_key(password: string, salt: &[byte]):[byte; 32] {
    password_bytes := password.as_bytes();
    key := pbkdf2_sha256(&password_bytes, salt, 100000, 32);
    
    // Convert to fixed-size array
    fixed_key := [byte; 32];
    for i in 0..32 {
        fixed_key[i] = key[i];
    }
    
    return fixed_key;
}

// Generate random IV for AES
export fn generate_aes_iv():[byte; 16] {
    bytes := random_bytes(16);
    
    iv := [byte; 16];
    for i in 0..16 {
        iv[i] = bytes[i];
    }
    
    return iv;
}

// Generate random salt
export fn generate_salt(len: usize):[byte] {
    return random_bytes(len);
}
