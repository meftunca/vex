struct HeaderEntry {
    key: string,
    value: string,
}

struct HeaderMap {
    entries: [HeaderEntry],
    size: usize,
}

export struct HttpResponse {
    status: u16,
    reason: string,
    version: string,
    headers: HeaderMap,
    body: string,
}

export fn new_response(status: u16): HttpResponse {
    reason := status_reason(status);
    
    return HttpResponse {
        status: status,
        reason: reason,
        version: "HTTP/1.1",
        headers: HeaderMap { entries: [], size: 0 },
        body: "",
    };
}

export fn (res: &HttpResponse) set_header(key: string, value: string): &HttpResponse {
    entry := HeaderEntry { key: key, value: value };
    res.headers.entries.push(entry);
    res.headers.size = res.headers.size + 1;
    return res;
}

export fn (res: &HttpResponse) set_body(body: string): &HttpResponse {
    res.body = body;
    content_length := body.len().to_string();
    res.headers.insert("Content-Length", content_length);
    return res;
}

export fn (res: &HttpResponse) to_bytes(): string {
    mut result := "";
    
    result = result + res.version + " " + res.status.to_string() + " " + res.reason + "\r\n";
    
    for entry in res.headers.entries {
        result = result + entry.key + ": " + entry.value + "\r\n";
    }
    
    result = result + "\r\n";
    
    if res.body.len() > 0 {
        result = result + res.body;
    }
    
    return result;
}

export fn parse_response(raw: string): (HttpResponse | error) {
    lines := raw.split("\r\n");
    
    if lines.len() < 1 {
        return error.new("Invalid HTTP response");
    }
    
    status_line := lines[0].split(" ");
    
    if status_line.len() < 3 {
        return error.new("Invalid status line");
    }
    
    status := status_line[1].parse_u16()?;
    reason := status_line[2..].join(" ");
    
    mut headers := HeaderMap { entries: [], size: 0 };
    mut body_start := 0;
    
    for i in 1..lines.len() {
        line := lines[i];
        
        if line.len() == 0 {
            body_start = i + 1;
            break;
        }
        
        parts := line.split(": ");
        if parts.len() >= 2 {
            entry := HeaderEntry { key: parts[0], value: parts[1] };
            headers.entries.push(entry);
            headers.size = headers.size + 1;
        }
    }
    
    mut body := "";
    if body_start < lines.len() {
        body = lines[body_start..].join("\r\n");
    }
    
    return HttpResponse {
        status: status,
        reason: reason,
        version: status_line[0],
        headers: headers,
        body: body,
    };
}

fn status_reason(status: u16): string {
    match status {
        200 => return "OK",
        201 => return "Created",
        204 => return "No Content",
        301 => return "Moved Permanently",
        302 => return "Found",
        304 => return "Not Modified",
        400 => return "Bad Request",
        401 => return "Unauthorized",
        403 => return "Forbidden",
        404 => return "Not Found",
        405 => return "Method Not Allowed",
        500 => return "Internal Server Error",
        502 => return "Bad Gateway",
        503 => return "Service Unavailable",
        _ => return "Unknown",
    }
}
