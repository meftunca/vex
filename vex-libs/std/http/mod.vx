// std::http - Layer 3: Application (100% Safe Native Vex)
// This layer knows NOTHING about sockets or io_uring.
// It only knows about Reader & Writer traits from std::io.

import { net, io } from "std";
import type { Reader, Writer } from "std::io";

// Connection type: anything that can read and write
type Connection = Reader & Writer;

// HTTP Response
struct Response {
    status_code: i32,
    headers: [Header],
    body: string,
}

// HTTP Header
struct Header {
    name: string,
    value: string,
}

// HTTP Request
struct Request {
    method: string,
    url: string,
    headers: [Header],
    body: string,
}

// Parse host and port from URL
fn parse_url(url: string) : ((string, i32, string) | error) {
    // Simple URL parsing: http://host:port/path
    // Real implementation would be more robust
    
    if !url.starts_with("http://") {
        return error.new("Only HTTP supported for now");
    }
    
    after_scheme := url[7..]; // Remove "http://"
    slash_pos := after_scheme.find("/");
    
    let host_port: string;
    let path: string;
    
    if slash_pos >= 0 {
        host_port = after_scheme[0..slash_pos];
        path = after_scheme[slash_pos..];
    } else {
        host_port = after_scheme;
        path = "/";
    }
    
    colon_pos := host_port.find(":");
    let host: string;
    let port: i32;
    
    if colon_pos >= 0 {
        host = host_port[0..colon_pos];
        port = host_port[colon_pos+1..].parse_int();
    } else {
        host = host_port;
        port = 80;
    }
    
    return (host, port, path);
}

// HTTP GET request
export async fn get(url: string) : (Response | error) {
    let (host, port, path) = try parse_url(url);
    
    // 1. Connect using std::net (Layer 2)
    conn := try await net.connect(host, port);
    
    // 2. Build HTTP request
    request := f"GET {path} HTTP/1.1\r\nHost: {host}\r\nConnection: close\r\n\r\n";
    request_bytes := request.as_bytes();
    
    // 3. Write request (conn is a Writer)
    try await conn.write(&request_bytes);
    
    // 4. Read response (conn is a Reader)
    response_buf := make([byte], 8192);
    n_read := try await conn.read(&response_buf);
    
    // 5. Close connection
    try await conn.close();
    
    // 6. Parse response in pure Vex
    response_str := string.from_bytes(&response_buf[0..n_read]);
    return parse_response(response_str);
}

// HTTP POST request
export async fn post(url: string, body: string, content_type: string) : (Response | error) {
    let (host, port, path) = try parse_url(url);
    
    conn := try await net.connect(host, port);
    
    body_len := body.len();
    request := f"POST {path} HTTP/1.1\r\n" +
                  f"Host: {host}\r\n" +
                  f"Content-Type: {content_type}\r\n" +
                  f"Content-Length: {body_len}\r\n" +
                  f"Connection: close\r\n\r\n" +
                  body;
    
    request_bytes := request.as_bytes();
    try await conn.write(&request_bytes);
    
    response_buf := make([byte], 8192);
    n_read := try await conn.read(&response_buf);
    
    try await conn.close();
    
    response_str := string.from_bytes(&response_buf[0..n_read]);
    return parse_response(response_str);
}

// Parse HTTP response (pure Vex string manipulation)
fn parse_response(raw: string) : (Response | error) {
    lines := raw.split("\r\n");
    
    if lines.len() < 1 {
        return error.new("Invalid HTTP response");
    }
    
    // Parse status line: "HTTP/1.1 200 OK"
    status_line := lines[0];
    status_parts := status_line.split(" ");
    
    if status_parts.len() < 2 {
        return error.new("Invalid status line");
    }
    
    status_code := status_parts[1].parse_int();
    
    // Parse headers until empty line
    let mut headers: [Header] = [];
    body_start := 0;
    
    for i := 1; i < lines.len(); i++ {
        if lines[i] == "" {
            body_start = i + 1;
            break;
        }
        
        colon_pos := lines[i].find(":");
        if colon_pos > 0 {
            name := lines[i][0..colon_pos];
            value := lines[i][colon_pos+1..].trim();
            headers.push(Header { name: name, value: value });
        }
    }
    
    // Everything after headers is body
    body := "";
    for i := body_start; i < lines.len(); i++ {
        body = body + lines[i];
        if i < lines.len() - 1 {
            body = body + "\r\n";
        }
    }
    
    return Response {
        status_code: status_code,
        headers: headers,
        body: body,
    };
}

// HTTP Server (Layer 3 server-side)
struct Server {
    listener: net.TcpListener,
}

// Create HTTP server
export async fn serve(addr: string, port: i32) : (Server | error) {
    listener := try await net.listen(addr, port);
    return Server { listener: listener };
}

// Handle incoming request
fn (s: &Server) handle_request(handler: fn(Request) : Response) : (nil | error) {
    loop {
        conn := try await s.listener.accept();
        
        // Read request
        req_buf := make([byte], 8192);
        n := try await conn.read(&req_buf);
        req_str := string.from_bytes(&req_buf[0..n]);
        
        // Parse and handle
        request := try parse_request(req_str);
        response := handler(request);
        
        // Send response
        resp_str := format_response(response);
        resp_bytes := resp_str.as_bytes();
        try await conn.write(&resp_bytes);
        
        try await conn.close();
    }
    
    return nil;
}

// Parse HTTP request
fn parse_request(raw: string) : (Request | error) {
    // Similar to parse_response, but for requests
    // Placeholder implementation
    return Request {
        method: "GET",
        url: "/",
        headers: [],
        body: "",
    };
}

// Format HTTP response
fn format_response(resp: Response) : string {
    status_text := if resp.status_code == 200 { "OK" } else { "Error" };
    result := f"HTTP/1.1 {resp.status_code} {status_text}\r\n";
    
    for header in resp.headers {
        result = result + f"{header.name}: {header.value}\r\n";
    }
    
    result = result + f"Content-Length: {resp.body.len()}\r\n";
    result = result + "\r\n";
    result = result + resp.body;
    
    return result;
}
