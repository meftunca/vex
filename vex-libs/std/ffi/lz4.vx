// std::ffi::lz4 - LZ4 compression library bindings
// Extremely fast compression (faster than zstd, less compression)

#[link(name = "lz4")]
extern {
    // Simple API - Compression
    fn LZ4_compress_default(src: *byte, dst: *byte,
                            src_size: i32, dst_capacity: i32):i32;
    
    fn LZ4_compress_fast(src: *byte, dst: *byte,
                         src_size: i32, dst_capacity: i32, 
                         acceleration: i32):i32;
    
    fn LZ4_compress_HC(src: *byte, dst: *byte,
                       src_size: i32, dst_capacity: i32, 
                       compression_level: i32):i32;
    
    // Simple API - Decompression
    fn LZ4_decompress_safe(src: *byte, dst: *byte,
                           compressed_size: i32, dst_capacity: i32):i32;
    
    fn LZ4_decompress_fast(src: *byte, dst: *byte,
                           original_size: i32):i32;
    
    // Bounds
    fn LZ4_compressBound(input_size: i32):i32;
    
    // Streaming API - Compression
    fn LZ4_createStream():*void;
    fn LZ4_freeStream(stream: *void):i32;
    fn LZ4_resetStream(stream: *void):*void;
    fn LZ4_compress_fast_continue(stream: *void, src: *byte, dst: *byte,
                                   src_size: i32, dst_capacity: i32,
                                   acceleration: i32):i32;
    
    // Streaming API - Decompression
    fn LZ4_createStreamDecode():*void;
    fn LZ4_freeStreamDecode(stream: *void):i32;
    fn LZ4_setStreamDecode(stream: *void, dict: *byte, dict_size: i32):i32;
    fn LZ4_decompress_safe_continue(stream: *void, src: *byte, dst: *byte,
                                     src_size: i32, dst_capacity: i32):i32;
    
    // Version
    fn LZ4_versionNumber():i32;
    fn LZ4_versionString():*byte;
}

// High Compression API
#[link(name = "lz4")]
extern {
    fn LZ4_createHC(src: *byte):*void;
    fn LZ4_freeHC(hc: *void):i32;
    fn LZ4_resetStreamHC(hc: *void, compression_level: i32):*void;
    fn LZ4_compress_HC_continue(hc: *void, src: *byte, dst: *byte,
                                src_size: i32, max_dst_size: i32):i32;
}

// Compression levels for HC mode
const LZ4HC_CLEVEL_MIN: i32 = 3;
const LZ4HC_CLEVEL_DEFAULT: i32 = 9;
const LZ4HC_CLEVEL_OPT_MIN: i32 = 10;
const LZ4HC_CLEVEL_MAX: i32 = 12;

// Acceleration values (higher = faster, less compression)
const LZ4_ACCELERATION_DEFAULT: i32 = 1;
const LZ4_ACCELERATION_MAX: i32 = 65537;

// Safe wrapper: Default compression
fn compress(data: [byte]):([byte] | error) {
    max_size := unsafe { LZ4_compressBound(data.len() as i32) };
    if max_size <= 0 {
        return error.new("Invalid input size");
    }
    
    compressed := make([byte], max_size as usize);
    
    result := unsafe {
        LZ4_compress_default(data.as_ptr(), compressed.as_mut_ptr(),
                            data.len() as i32, max_size)
    };
    
    if result <= 0 {
        return error.new("LZ4 compression failed");
    }
    
    compressed.resize(result as usize);
    return compressed;
}

// Safe wrapper: Fast compression with acceleration
fn compress_fast(data: [byte], acceleration: i32):([byte] | error) {
    max_size := unsafe { LZ4_compressBound(data.len() as i32) };
    if max_size <= 0 {
        return error.new("Invalid input size");
    }
    
    compressed := make([byte], max_size as usize);
    
    result := unsafe {
        LZ4_compress_fast(data.as_ptr(), compressed.as_mut_ptr(),
                         data.len() as i32, max_size, acceleration)
    };
    
    if result <= 0 {
        return error.new("LZ4 fast compression failed");
    }
    
    compressed.resize(result as usize);
    return compressed;
}

// Safe wrapper: High compression
fn compress_hc(data: [byte], level: i32):([byte] | error) {
    max_size := unsafe { LZ4_compressBound(data.len() as i32) };
    if max_size <= 0 {
        return error.new("Invalid input size");
    }
    
    compressed := make([byte], max_size as usize);
    
    result := unsafe {
        LZ4_compress_HC(data.as_ptr(), compressed.as_mut_ptr(),
                       data.len() as i32, max_size, level)
    };
    
    if result <= 0 {
        return error.new("LZ4 HC compression failed");
    }
    
    compressed.resize(result as usize);
    return compressed;
}

// Safe wrapper: Decompression (safe, requires original size)
fn decompress(compressed: [byte], original_size: usize):([byte] | error) {
    decompressed := make([byte], original_size);
    
    result := unsafe {
        LZ4_decompress_safe(compressed.as_ptr(), decompressed.as_mut_ptr(),
                           compressed.len() as i32, original_size as i32)
    };
    
    if result < 0 {
        return error.new("LZ4 decompression failed");
    }
    
    return decompressed;
}

// Streaming compression context
struct LZ4Stream {
    handle: *void,
}

fn create_stream():(LZ4Stream | error) {
    handle := unsafe { LZ4_createStream() };
    if handle as usize == 0 {
        return error.new("Failed to create LZ4 stream");
    }
    return LZ4Stream { handle: handle };
}

fn free_stream(stream: LZ4Stream) {
    unsafe { LZ4_freeStream(stream.handle); }
}

// Ultra-fast compression (acceleration = 10, sacrifices compression ratio)
fn compress_ultra_fast(data: [byte]):([byte] | error) {
    return compress_fast(data, 10);
}
