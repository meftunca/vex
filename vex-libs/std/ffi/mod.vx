// std.ffi - Foreign Function Interface (FFI)
// Production-ready FFI with zero-overhead C interop

// Import core libc bindings
import { libc } from "./libc";

// Platform-specific imports
#[cfg(unix)]
import { unix } from "./platform/unix";

#[cfg(windows)]
import { windows } from "./platform/windows";

// Import compression libraries
import { zlib } from "./zlib";
import { zstd } from "./zstd";
import { lz4 } from "./lz4";

// Import crypto library
import { openssl } from "./openssl";

// Re-export all FFI modules
export { libc, zlib, zstd, lz4, openssl };

// C string type (null-terminated)
export struct CString {
    ptr: *byte,
    len: usize,
}

// Convert Vex string to C string (malloc-based)
export fn to_c_string(s: string) : CString {
    bytes := s.as_bytes();
    len := bytes.len();
    
    // Allocate len + 1 for null terminator
    ptr := unsafe { libc.malloc(len + 1) };
    
    // Copy bytes
    unsafe { libc.memcpy(ptr, bytes.as_ptr(), len); }
    
    // Add null terminator
    unsafe { *(ptr + len) = 0; }
    
    return CString { ptr: ptr, len: len };
}

// Convert C string to Vex string
export fn from_c_string(cstr: CString) : string {
    bytes := make([byte], cstr.len);
    
    unsafe { libc.memcpy(bytes.as_mut_ptr(), cstr.ptr, cstr.len); }
    
    return string.from_bytes(bytes);
}

// Free C string
export fn free_c_string(cstr: CString) {
    unsafe { libc.free(cstr.ptr); }
}

// Dynamic library loading
export struct LibHandle {
    handle: *void,
}

// C function pointer type
export type CFunctionPtr = *fn();

// Load dynamic library (platform-abstracted)
export fn load_library(path: string) : (LibHandle | error) {
    c_path := to_c_string(path);
    
    #[cfg(unix)]
    handle := unsafe { unix.dlopen(c_path.ptr, unix.RTLD_NOW) };
    
    #[cfg(windows)]
    handle := unsafe { windows.LoadLibraryA(c_path.ptr) };
    
    free_c_string(c_path);
    
    if handle as usize == 0 {
        return error.new("Failed to load library");
    }
    
    return LibHandle { handle: handle };
}

// Look up symbol in library
export fn get_symbol(lib: LibHandle, name: string) : (CFunctionPtr | error) {
    c_name := to_c_string(name);
    
    #[cfg(unix)]
    sym := unsafe { unix.dlsym(lib.handle, c_name.ptr) };
    
    #[cfg(windows)]
    sym := unsafe { windows.GetProcAddress(lib.handle, c_name.ptr) };
    
    free_c_string(c_name);
    
    if sym as usize == 0 {
        return error.new("Symbol not found");
    }
    
    return sym as CFunctionPtr;
}

// Close dynamic library
export fn close_library(lib: LibHandle) {
    #[cfg(unix)]
    unsafe { unix.dlclose(lib.handle); }
    
    #[cfg(windows)]
    unsafe { windows.FreeLibrary(lib.handle); }
}

// Common C types
export type c_char = i8;
export type c_uchar = u8;
export type c_short = i16;
export type c_ushort = u16;
export type c_int = i32;
export type c_uint = u32;
export type c_long = i64;
export type c_ulong = u64;
export type c_float = f32;
export type c_double = f64;
export type c_void = byte;

// Example of calling external C function:
//
// extern {
//     fn strlen(s: *byte) : u32;
//     fn printf(fmt: *byte, ...) : i32;
// }
//
// fn main() : i32 {
//     msg := ffi.to_c_string("Hello from Vex!");
//     unsafe {
//         printf("Message: %s\n".as_ptr(), msg.ptr);
//         len := strlen(msg.ptr);
//         printf("Length: %d\n".as_ptr(), len);
//     }
//     ffi.free_c_string(msg);
//     return 0;
// }
