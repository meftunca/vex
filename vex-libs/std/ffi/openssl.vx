// std::ffi::openssl - OpenSSL cryptography library bindings
// TLS, crypto, hashing, and more

// ==================== SSL/TLS ====================

#[link(name = "ssl")]
extern {
    // Initialization
    fn SSL_library_init():i32;
    fn SSL_load_error_strings();
    fn OpenSSL_add_all_algorithms();
    
    // SSL Context
    fn SSL_CTX_new(method: *void):*void;
    fn SSL_CTX_free(ctx: *void);
    fn SSL_CTX_set_verify(ctx: *void, mode: i32, callback: *fn());
    fn SSL_CTX_use_certificate_file(ctx: *void, file: *byte, type_: i32):i32;
    fn SSL_CTX_use_PrivateKey_file(ctx: *void, file: *byte, type_: i32):i32;
    
    // SSL Methods
    fn TLS_method():*void;
    fn TLS_client_method():*void;
    fn TLS_server_method():*void;
    fn SSLv23_method():*void;
    
    // SSL Connection
    fn SSL_new(ctx: *void):*void;
    fn SSL_free(ssl: *void);
    fn SSL_set_fd(ssl: *void, fd: i32):i32;
    fn SSL_connect(ssl: *void):i32;
    fn SSL_accept(ssl: *void):i32;
    fn SSL_read(ssl: *void, buf: *byte, num: i32):i32;
    fn SSL_write(ssl: *void, buf: *byte, num: i32):i32;
    fn SSL_shutdown(ssl: *void):i32;
    
    // Error handling
    fn SSL_get_error(ssl: *void, ret: i32):i32;
    fn ERR_get_error():u64;
    fn ERR_error_string(e: u64, buf: *byte):*byte;
}

// ==================== Crypto ====================

#[link(name = "crypto")]
extern {
    // Hashing - SHA256
    fn SHA256_Init(ctx: *SHA256_CTX):i32;
    fn SHA256_Update(ctx: *SHA256_CTX, data: *byte, len: usize):i32;
    fn SHA256_Final(md: *byte, ctx: *SHA256_CTX):i32;
    fn SHA256(data: *byte, len: usize, md: *byte):*byte;
    
    // Hashing - SHA512
    fn SHA512_Init(ctx: *SHA512_CTX):i32;
    fn SHA512_Update(ctx: *SHA512_CTX, data: *byte, len: usize):i32;
    fn SHA512_Final(md: *byte, ctx: *SHA512_CTX):i32;
    fn SHA512(data: *byte, len: usize, md: *byte):*byte;
    
    // Hashing - MD5 (legacy, don't use for security!)
    fn MD5_Init(ctx: *MD5_CTX):i32;
    fn MD5_Update(ctx: *MD5_CTX, data: *byte, len: usize):i32;
    fn MD5_Final(md: *byte, ctx: *MD5_CTX):i32;
    fn MD5(data: *byte, len: usize, md: *byte):*byte;
    
    // HMAC
    fn HMAC(evp_md: *void, key: *byte, key_len: i32,
            data: *byte, data_len: usize, md: *byte, md_len: *u32):*byte;
    
    // AES Encryption
    fn AES_set_encrypt_key(userKey: *byte, bits: i32, key: *AES_KEY):i32;
    fn AES_set_decrypt_key(userKey: *byte, bits: i32, key: *AES_KEY):i32;
    fn AES_encrypt(in_: *byte, out: *byte, key: *AES_KEY);
    fn AES_decrypt(in_: *byte, out: *byte, key: *AES_KEY);
    
    // Random number generation
    fn RAND_bytes(buf: *byte, num: i32):i32;
    fn RAND_pseudo_bytes(buf: *byte, num: i32):i32;
    
    // Base64 encoding/decoding
    fn EVP_EncodeBlock(t: *byte, f: *byte, n: i32):i32;
    fn EVP_DecodeBlock(t: *byte, f: *byte, n: i32):i32;
    
    // EVP digest functions (modern API)
    fn EVP_sha256():*void;
    fn EVP_sha512():*void;
    fn EVP_md5():*void;
}

// SHA256 context (64 bytes on most platforms)
struct SHA256_CTX {
    state: [u32; 8],
    count: [u64; 2],
    buffer: [byte; 64],
}

// SHA512 context
struct SHA512_CTX {
    state: [u64; 8],
    count: [u64; 2],
    buffer: [byte; 128],
}

// MD5 context
struct MD5_CTX {
    state: [u32; 4],
    count: [u64; 2],
    buffer: [byte; 64],
}

// AES key structure (opaque, size depends on key length)
struct AES_KEY {
    rd_key: [u32; 60],
    rounds: i32,
}

// SSL/TLS constants
const SSL_FILETYPE_PEM: i32 = 1;
const SSL_FILETYPE_ASN1: i32 = 2;

const SSL_VERIFY_NONE: i32 = 0;
const SSL_VERIFY_PEER: i32 = 1;
const SSL_VERIFY_FAIL_IF_NO_PEER_CERT: i32 = 2;

const SSL_ERROR_NONE: i32 = 0;
const SSL_ERROR_SSL: i32 = 1;
const SSL_ERROR_WANT_READ: i32 = 2;
const SSL_ERROR_WANT_WRITE: i32 = 3;
const SSL_ERROR_SYSCALL: i32 = 5;
const SSL_ERROR_ZERO_RETURN: i32 = 6;

// Hash sizes
const SHA256_DIGEST_LENGTH: usize = 32;
const SHA512_DIGEST_LENGTH: usize = 64;
const MD5_DIGEST_LENGTH: usize = 16;

// ==================== Safe Wrappers ====================

// SHA256 one-shot hash
fn sha256(data: [byte]):[byte; 32] {
    let mut hash: [byte; 32] = [0; 32];
    unsafe {
        SHA256(data.as_ptr(), data.len(), hash.as_mut_ptr());
    }
    return hash;
}

// SHA512 one-shot hash
fn sha512(data: [byte]):[byte; 64] {
    let mut hash: [byte; 64] = [0; 64];
    unsafe {
        SHA512(data.as_ptr(), data.len(), hash.as_mut_ptr());
    }
    return hash;
}

// MD5 one-shot hash (legacy)
fn md5(data: [byte]):[byte; 16] {
    let mut hash: [byte; 16] = [0; 16];
    unsafe {
        MD5(data.as_ptr(), data.len(), hash.as_mut_ptr());
    }
    return hash;
}

// HMAC-SHA256
fn hmac_sha256(key: [byte], data: [byte]):[byte; 32] {
    let mut hash: [byte; 32] = [0; 32];
    let mut md_len: u32 = 32;
    
    unsafe {
        evp_sha256 := EVP_sha256();
        HMAC(evp_sha256, key.as_ptr(), key.len() as i32,
             data.as_ptr(), data.len(), hash.as_mut_ptr(), &md_len);
    }
    
    return hash;
}

// Generate random bytes
fn random_bytes(count: usize):([byte] | error) {
    buf := make([byte], count);
    
    result := unsafe { RAND_bytes(buf.as_mut_ptr(), count as i32) };
    
    if result != 1 {
        return error.new("Failed to generate random bytes");
    }
    
    return buf;
}

// Base64 encode
fn base64_encode(data: [byte]):string {
    out_len := ((data.len() + 2) / 3) * 4;
    encoded := make([byte], out_len + 1);
    
    unsafe {
        EVP_EncodeBlock(encoded.as_mut_ptr(), data.as_ptr(), data.len() as i32);
    }
    
    return string.from_bytes(encoded);
}

// Base64 decode
fn base64_decode(encoded: string):([byte] | error) {
    bytes := encoded.as_bytes();
    out_len := (bytes.len() * 3) / 4;
    decoded := make([byte], out_len);
    
    result := unsafe {
        EVP_DecodeBlock(decoded.as_mut_ptr(), bytes.as_ptr(), bytes.len() as i32)
    };
    
    if result < 0 {
        return error.new("Invalid base64 data");
    }
    
    decoded.resize(result as usize);
    return decoded;
}

// SSL Context wrapper
struct SSLContext {
    ctx: *void,
}

fn create_ssl_context(is_server: bool):(SSLContext | error) {
    // Initialize OpenSSL
    unsafe {
        SSL_library_init();
        SSL_load_error_strings();
        OpenSSL_add_all_algorithms();
    }
    
    method := if is_server {
        unsafe { TLS_server_method() }
    } else {
        unsafe { TLS_client_method() }
    };
    
    ctx := unsafe { SSL_CTX_new(method) };
    
    if ctx as usize == 0 {
        return error.new("Failed to create SSL context");
    }
    
    return SSLContext { ctx: ctx };
}

fn free_ssl_context(ctx: SSLContext) {
    unsafe { SSL_CTX_free(ctx.ctx); }
}

// SSL Connection wrapper
struct SSLConnection {
    ssl: *void,
}

fn create_ssl_connection(ctx: SSLContext, fd: i32):(SSLConnection | error) {
    ssl := unsafe { SSL_new(ctx.ctx) };
    
    if ssl as usize == 0 {
        return error.new("Failed to create SSL connection");
    }
    
    result := unsafe { SSL_set_fd(ssl, fd) };
    if result != 1 {
        unsafe { SSL_free(ssl); }
        return error.new("Failed to set file descriptor");
    }
    
    return SSLConnection { ssl: ssl };
}

fn ssl_connect(conn: SSLConnection):(i32 | error) {
    result := unsafe { SSL_connect(conn.ssl) };
    if result != 1 {
        err := unsafe { SSL_get_error(conn.ssl, result) };
        return error.new(f"SSL connect failed: {err}");
    }
    return result;
}

fn ssl_read(conn: SSLConnection, buf: [byte]):(i32 | error) {
    result := unsafe { SSL_read(conn.ssl, buf.as_mut_ptr(), buf.len() as i32) };
    if result < 0 {
        err := unsafe { SSL_get_error(conn.ssl, result) };
        return error.new(f"SSL read failed: {err}");
    }
    return result;
}

fn ssl_write(conn: SSLConnection, data: [byte]):(i32 | error) {
    result := unsafe { SSL_write(conn.ssl, data.as_ptr(), data.len() as i32) };
    if result < 0 {
        err := unsafe { SSL_get_error(conn.ssl, result) };
        return error.new(f"SSL write failed: {err}");
    }
    return result;
}

fn free_ssl_connection(conn: SSLConnection) {
    unsafe {
        SSL_shutdown(conn.ssl);
        SSL_free(conn.ssl);
    }
}
