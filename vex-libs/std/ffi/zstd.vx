// std::ffi::zstd - Zstandard compression library bindings
// Modern, fast compression by Facebook (better than zlib)

#[link(name = "zstd")]
extern {
    // Simple API - One-shot compression
    fn ZSTD_compress(dst: *byte, dst_capacity: usize,
                     src: *byte, src_size: usize, 
                     compression_level: i32):usize;
    
    fn ZSTD_decompress(dst: *byte, dst_capacity: usize,
                       src: *byte, compressed_size: usize):usize;
    
    // Get bounds
    fn ZSTD_compressBound(src_size: usize):usize;
    fn ZSTD_getFrameContentSize(src: *byte, src_size: usize):u64;
    
    // Error handling
    fn ZSTD_isError(code: usize):u32;
    fn ZSTD_getErrorName(code: usize):*byte;
    
    // Compression context (streaming)
    fn ZSTD_createCCtx():*void;
    fn ZSTD_freeCCtx(cctx: *void):usize;
    fn ZSTD_compressCCtx(cctx: *void, dst: *byte, dst_capacity: usize,
                         src: *byte, src_size: usize, compression_level: i32):usize;
    
    // Decompression context (streaming)
    fn ZSTD_createDCtx():*void;
    fn ZSTD_freeDCtx(dctx: *void):usize;
    fn ZSTD_decompressDCtx(dctx: *void, dst: *byte, dst_capacity: usize,
                           src: *byte, src_size: usize):usize;
    
    // Dictionary compression (for small data)
    fn ZSTD_compress_usingDict(ctx: *void, dst: *byte, dst_capacity: usize,
                                src: *byte, src_size: usize,
                                dict: *byte, dict_size: usize,
                                compression_level: i32):usize;
    
    fn ZSTD_decompress_usingDict(dctx: *void, dst: *byte, dst_capacity: usize,
                                  src: *byte, src_size: usize,
                                  dict: *byte, dict_size: usize):usize;
    
    // Version
    fn ZSTD_versionNumber():u32;
    fn ZSTD_versionString():*byte;
}

// Compression levels
export const ZSTD_MIN_CLEVEL: i32 = 1;
export const ZSTD_MAX_CLEVEL: i32 = 22;
export const ZSTD_DEFAULT_CLEVEL: i32 = 3;

// Fast compression levels (negative)
export const ZSTD_FAST_1: i32 = -1;
export const ZSTD_FAST_5: i32 = -5;
export const ZSTD_FAST_10: i32 = -10;

// Special return values
export const ZSTD_CONTENTSIZE_UNKNOWN: u64 = 0xFFFFFFFFFFFFFFFF;
export const ZSTD_CONTENTSIZE_ERROR: u64 = 0xFFFFFFFFFFFFFFFE;

// Safe wrapper: Compress with automatic size calculation
export fn compress(data: [byte], level: i32):([byte] | error) {
    max_size := unsafe { ZSTD_compressBound(data.len()) };
    compressed := make([byte], max_size);
    
    result := unsafe {
        ZSTD_compress(compressed.as_mut_ptr(), max_size,
                     data.as_ptr(), data.len(), level)
    };
    
    // Check for error
    is_error := unsafe { ZSTD_isError(result) };
    if is_error != 0 {
        return error.new("Zstd compression failed");
    }
    
    // Resize to actual size
    compressed.resize(result);
    return compressed;
}

// Safe wrapper: Decompress with size detection
export fn decompress(compressed: [byte]):([byte] | error) {
    // Get original size from frame header
    content_size := unsafe {
        ZSTD_getFrameContentSize(compressed.as_ptr(), compressed.len())
    };
    
    if content_size == ZSTD_CONTENTSIZE_UNKNOWN {
        return error.new("Unknown decompressed size");
    }
    
    if content_size == ZSTD_CONTENTSIZE_ERROR {
        return error.new("Invalid zstd frame");
    }
    
    decompressed := make([byte], content_size as usize);
    
    result := unsafe {
        ZSTD_decompress(decompressed.as_mut_ptr(), content_size as usize,
                       compressed.as_ptr(), compressed.len())
    };
    
    is_error := unsafe { ZSTD_isError(result) };
    if is_error != 0 {
        return error.new("Zstd decompression failed");
    }
    
    return decompressed;
}

// Fast compression (level -1, very fast)
export fn compress_fast(data: [byte]):([byte] | error) {
    return compress(data, ZSTD_FAST_1);
}

// Best compression (level 19, very slow but maximum compression)
export fn compress_best(data: [byte]):([byte] | error) {
    return compress(data, 19);
}

// Dictionary-based compression (good for small repeated data)
export struct ZstdDict {
    data: [byte],
}

export fn compress_with_dict(data: [byte], dict: ZstdDict, level: i32):([byte] | error) {
    ctx := unsafe { ZSTD_createCCtx() };
    if ctx as usize == 0 {
        return error.new("Failed to create compression context");
    }
    
    max_size := unsafe { ZSTD_compressBound(data.len()) };
    compressed := make([byte], max_size);
    
    result := unsafe {
        ZSTD_compress_usingDict(ctx, compressed.as_mut_ptr(), max_size,
                               data.as_ptr(), data.len(),
                               dict.data.as_ptr(), dict.data.len(), level)
    };
    
    unsafe { ZSTD_freeCCtx(ctx); }
    
    is_error := unsafe { ZSTD_isError(result) };
    if is_error != 0 {
        return error.new("Dictionary compression failed");
    }
    
    compressed.resize(result);
    return compressed;
}
