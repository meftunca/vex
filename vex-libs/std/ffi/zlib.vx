// std::ffi::zlib - zlib compression library bindings
// Widely used compression library (HTTP, PNG, etc.)

#[link(name = "z")]
extern {
    // Compression
    fn compress(dest: *byte, dest_len: *usize, 
                source: *byte, source_len: usize):i32;
    fn compress2(dest: *byte, dest_len: *usize,
                 source: *byte, source_len: usize, level: i32):i32;
    
    // Decompression
    fn uncompress(dest: *byte, dest_len: *usize,
                  source: *byte, source_len: usize):i32;
    
    // Advanced compression with streams
    fn deflate(strm: *z_stream, flush: i32):i32;
    fn deflateInit_(strm: *z_stream, level: i32,
                    version: *byte, stream_size: i32):i32;
    fn deflateEnd(strm: *z_stream):i32;
    
    // Advanced decompression with streams
    fn inflate(strm: *z_stream, flush: i32):i32;
    fn inflateInit_(strm: *z_stream, version: *byte, stream_size: i32):i32;
    fn inflateEnd(strm: *z_stream):i32;
    
    // Utility functions
    fn crc32(crc: u32, buf: *byte, len: u32):u32;
    fn adler32(adler: u32, buf: *byte, len: u32):u32;
    
    // Version
    fn zlibVersion():*byte;
}

// zlib stream structure
struct z_stream {
    next_in: *byte,
    avail_in: u32,
    total_in: u64,
    
    next_out: *byte,
    avail_out: u32,
    total_out: u64,
    
    msg: *byte,
    state: *void,
    
    zalloc: *fn(*void, u32, u32):*void,
    zfree: *fn(*void, *void),
    opaque: *void,
    
    data_type: i32,
    adler: u64,
    reserved: u64,
}

// Return codes
const Z_OK: i32 = 0;
const Z_STREAM_END: i32 = 1;
const Z_NEED_DICT: i32 = 2;
const Z_ERRNO: i32 = -1;
const Z_STREAM_ERROR: i32 = -2;
const Z_DATA_ERROR: i32 = -3;
const Z_MEM_ERROR: i32 = -4;
const Z_BUF_ERROR: i32 = -5;
const Z_VERSION_ERROR: i32 = -6;

// Compression levels
const Z_NO_COMPRESSION: i32 = 0;
const Z_BEST_SPEED: i32 = 1;
const Z_BEST_COMPRESSION: i32 = 9;
const Z_DEFAULT_COMPRESSION: i32 = -1;

// Flush values
const Z_NO_FLUSH: i32 = 0;
const Z_PARTIAL_FLUSH: i32 = 1;
const Z_SYNC_FLUSH: i32 = 2;
const Z_FULL_FLUSH: i32 = 3;
const Z_FINISH: i32 = 4;
const Z_BLOCK: i32 = 5;
const Z_TREES: i32 = 6;

// Safe wrapper: Simple compression
fn compress_data(data: [byte], level: i32):([byte] | error) {
    source_len := data.len();
    dest_len := source_len + (source_len / 1000) + 12; // zlib overhead
    dest := make([byte], dest_len);
    
    actual_len := dest_len;
    result := unsafe {
        compress2(dest.as_mut_ptr(), &actual_len,
                 data.as_ptr(), source_len, level)
    };
    
    if result != Z_OK {
        return error.new("Compression failed");
    }
    
    // Resize to actual compressed size
    dest.resize(actual_len);
    return dest;
}

// Safe wrapper: Simple decompression
fn decompress_data(compressed: [byte], expected_size: usize):([byte] | error) {
    dest := make([byte], expected_size);
    actual_len := expected_size;
    
    result := unsafe {
        uncompress(dest.as_mut_ptr(), &actual_len,
                  compressed.as_ptr(), compressed.len())
    };
    
    if result != Z_OK {
        return error.new("Decompression failed");
    }
    
    return dest;
}

// CRC32 checksum
fn calculate_crc32(data: [byte]):u32 {
    return unsafe { crc32(0, data.as_ptr(), data.len() as u32) };
}
