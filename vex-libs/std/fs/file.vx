// std::fs::file - File operations

import { libc } from "../ffi";

export struct File {
    fd: i32,
    path: string,
    is_open: bool,
}

// Open file for reading
export fn open(path: string):(File | error) {
    return open_with_flags(path, libc.O_RDONLY);
}

// Open file with specific flags
export fn open_with_flags(path: string, flags: i32):(File | error) {
    path_cstr := to_c_string(path);
    defer libc.safe_free(path_cstr);
    
    fd := unsafe { libc.open(path_cstr, flags, 0o644) };
    
    if fd < 0 {
        return error.new("Failed to open file");
    }
    
    return File {
        fd: fd,
        path: path,
        is_open: true,
    };
}

// Create new file (truncate if exists)
export fn create(path: string):(File | error) {
    return open_with_flags(path, libc.O_CREAT | libc.O_WRONLY | libc.O_TRUNC);
}

// Open file for append
export fn open_append(path: string):(File | error) {
    return open_with_flags(path, libc.O_CREAT | libc.O_WRONLY | libc.O_APPEND);
}

// Read from file
export fn read(file: *File, buffer: *byte, size: usize):(i64 | error) {
    if !file.is_open {
        return error.new("File not open");
    }
    
    bytes_read := unsafe { libc.read(file.fd, buffer, size) };
    
    if bytes_read < 0 {
        return error.new("Failed to read from file");
    }
    
    return bytes_read;
}

// Write to file
export fn write(file: *File, data: *byte, size: usize):(i64 | error) {
    if !file.is_open {
        return error.new("File not open");
    }
    
    bytes_written := unsafe { libc.write(file.fd, data, size) };
    
    if bytes_written < 0 {
        return error.new("Failed to write to file");
    }
    
    return bytes_written;
}

// Seek to position
export fn seek(file: *File, offset: i64, whence: i32):(i64 | error) {
    if !file.is_open {
        return error.new("File not open");
    }
    
    return libc.safe_lseek(file.fd, offset, whence);
}

// Get current position
export fn tell(file: *File):(i64 | error) {
    return seek(file, 0, libc.SEEK_CUR);
}

// Get file size
export fn size(file: *File):(i64 | error) {
    if !file.is_open {
        return error.new("File not open");
    }
    
    // Seek to end, get position, seek back
    current := tell(file)?;
    end_pos := seek(file, 0, libc.SEEK_END)?;
    seek(file, current, libc.SEEK_SET)?;
    
    return end_pos;
}

// Close file
export fn close(file: *File):(bool | error) {
    if !file.is_open {
        return true; // Already closed
    }
    
    result := unsafe { libc.close(file.fd) };
    
    if result != 0 {
        return error.new("Failed to close file");
    }
    
    file.is_open = false;
    return true;
}

// Helper: Convert string to C string
export fn to_c_string(s: string):*byte {
    len := s.len();
    ptr_result := libc.safe_malloc(len + 1);
    
    match ptr_result {
        ptr: *byte => {
            src := s.as_ptr();
            unsafe { libc.memcpy(ptr, src, len); }
            unsafe { *(ptr + len) = 0; }
            return ptr;
        },
        err: error => {
            return 0 as *byte;
        },
    }
}
