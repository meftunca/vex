import { libc } from "../ffi";

export struct Glob {
    pattern: string,
    matches: [string],
}

export fn new(pattern: string): Glob {
    return Glob {
        pattern: pattern,
        matches: [],
    };
}

export fn (g: &Glob) match_path(path: string): bool {
    return glob_match(g.pattern, path);
}

export fn glob(pattern: string): [string] {
    return [];
}

fn glob_match(pattern: string, text: string): bool {
    return glob_match_impl(pattern, 0, text, 0);
}

fn glob_match_impl(pattern: string, pi: usize, text: string, ti: usize): bool {
    plen := pattern.len();
    tlen := text.len();
    
    if pi >= plen {
        return ti >= tlen;
    }
    
    pc := pattern.char_at(pi);
    
    if pc == '*' {
        if pi + 1 >= plen {
            return true;
        }
        
        if pi + 1 < plen && pattern.char_at(pi + 1) == '*' {
            return glob_match_doublestar(pattern, pi + 2, text, ti);
        }
        
        i := ti;
        while i <= tlen {
            if glob_match_impl(pattern, pi + 1, text, i) {
                return true;
            }
            i = i + 1;
        }
        return false;
    }
    
    if pc == '?' {
        if ti >= tlen {
            return false;
        }
        return glob_match_impl(pattern, pi + 1, text, ti + 1);
    }
    
    if pc == '[' {
        if ti >= tlen {
            return false;
        }
        
        close_idx := find_closing_bracket(pattern, pi + 1);
        if close_idx == -1 {
            return false;
        }
        
        tc := text.char_at(ti);
        matched := match_char_class(pattern, pi + 1, close_idx, tc);
        
        if matched {
            return glob_match_impl(pattern, close_idx + 1, text, ti + 1);
        }
        return false;
    }
    
    if ti >= tlen {
        return false;
    }
    
    tc := text.char_at(ti);
    if pc != tc {
        return false;
    }
    
    return glob_match_impl(pattern, pi + 1, text, ti + 1);
}

fn glob_match_doublestar(pattern: string, pi: usize, text: string, ti: usize): bool {
    plen := pattern.len();
    tlen := text.len();
    
    if pi >= plen {
        return true;
    }
    
    i := ti;
    while i <= tlen {
        if glob_match_impl(pattern, pi, text, i) {
            return true;
        }
        
        if i < tlen && text.char_at(i) == '/' {
            i = i + 1;
        } else {
            i = i + 1;
        }
    }
    
    return false;
}

fn find_closing_bracket(pattern: string, start: usize): i32 {
    i := start;
    while i < pattern.len() {
        if pattern.char_at(i) == ']' {
            return i as i32;
        }
        i = i + 1;
    }
    return -1;
}

fn match_char_class(pattern: string, start: usize, end: usize, c: char): bool {
    negate := false;
    i := start;
    
    if i < end && pattern.char_at(i) == '!' {
        negate = true;
        i = i + 1;
    }
    
    matched := false;
    
    while i < end {
        pc := pattern.char_at(i);
        
        if i + 2 < end && pattern.char_at(i + 1) == '-' {
            start_c := pc;
            end_c := pattern.char_at(i + 2);
            
            if c >= start_c && c <= end_c {
                matched = true;
            }
            
            i = i + 3;
        } else {
            if c == pc {
                matched = true;
            }
            i = i + 1;
        }
    }
    
    return if negate { !matched } else { matched };
}

export fn matches(pattern: string, text: string): bool {
    return glob_match(pattern, text);
}

export fn match_multiple(patterns: [string], text: string): bool {
    for pattern in patterns {
        if glob_match(pattern, text) {
            return true;
        }
    }
    return false;
}
