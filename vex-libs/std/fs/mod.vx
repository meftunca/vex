import { libc } from "../ffi";

export { File } from "./file";
import * as file_mod from "./file";

export { BufReader, BufWriter, new_buf_reader, new_buf_writer } from "./buffer";
export { Path, join as path_join, normalize as path_normalize, SEPARATOR } from "./path";
export { Glob, matches as glob_matches, match_multiple as glob_match_multiple } from "./glob";

// ============================================================================
// File Operations
// ============================================================================

// Read entire file to string
export fn read_to_string(path: string):(string | error) {
    file := file_mod.open(path)?;
    defer file_mod.close(&file);
    
    file_size := file_mod.size(&file)?;
    
    if file_size == 0 {
        return "";
    }
    
    buffer := libc.safe_malloc(file_size as usize)?;
    defer libc.safe_free(buffer);
    
    bytes_read := file_mod.read(&file, buffer, file_size as usize)?;
    
    // Convert to string (simplified, needs proper implementation)
    return "";  // TODO: Implement byte array to string conversion
}

// Write string to file (create or truncate)
export fn write(path: string, content: string):(bool | error) {
    file := file_mod.create(path)?;
    defer file_mod.close(&file);
    
    data := content.as_bytes();
    file_mod.write(&file, data.as_ptr(), data.len())?;
    
    return true;
}

// Append string to file
export fn append(path: string, content: string):(bool | error) {
    file := file_mod.open_append(path)?;
    defer file_mod.close(&file);
    
    data := content.as_bytes();
    file_mod.write(&file, data.as_ptr(), data.len())?;
    
    return true;
}

// Copy file
export fn copy(from: string, to: string):(bool | error) {
    src := file_mod.open(from)?;
    defer file_mod.close(&src);
    
    dst := file_mod.create(to)?;
    defer file_mod.close(&dst);
    
    // Copy in 4KB chunks
    let buffer_size: usize = 4096;
    buffer := libc.safe_malloc(buffer_size)?;
    defer libc.safe_free(buffer);
    
    loop {
        bytes_read := file_mod.read(&src, buffer, buffer_size)?;
        
        if bytes_read == 0 {
            break;
        }
        
        file_mod.write(&dst, buffer, bytes_read as usize)?;
    }
    
    return true;
}

// Remove file
export fn remove_file(path: string):(bool | error) {
    path_cstr := to_c_string(path);
    defer libc.safe_free(path_cstr);
    
    libc.safe_unlink(path_cstr)?;
    return true;
}

export fn rename(from: string, to: string): (bool | error) {
    from_cstr := to_c_string(from);
    defer libc.safe_free(from_cstr);
    
    to_cstr := to_c_string(to);
    defer libc.safe_free(to_cstr);
    
    libc.safe_rename(from_cstr, to_cstr)?;
    return true;
}

export fn symlink(target: string, link: string): (bool | error) {
    target_cstr := to_c_string(target);
    defer libc.safe_free(target_cstr);
    
    link_cstr := to_c_string(link);
    defer libc.safe_free(link_cstr);
    
    result := unsafe { libc.symlink(target_cstr, link_cstr) };
    if result != 0 {
        return error.new("Failed to create symlink");
    }
    return true;
}

export fn read_link(path: string): (string | error) {
    path_cstr := to_c_string(path);
    defer libc.safe_free(path_cstr);
    
    buffer := libc.safe_malloc(4096)?;
    defer libc.safe_free(buffer);
    
    size := unsafe { libc.readlink(path_cstr, buffer, 4096) };
    if size < 0 {
        return error.new("Failed to read symlink");
    }
    
    return "";
}

export fn chmod(path: string, mode: u32): (bool | error) {
    path_cstr := to_c_string(path);
    defer libc.safe_free(path_cstr);
    
    result := unsafe { libc.chmod(path_cstr, mode) };
    if result != 0 {
        return error.new("Failed to change permissions");
    }
    return true;
}

// ============================================================================
// Directory Operations
// ============================================================================

// Create directory with default permissions (0755)
export fn create_dir(path: string):(bool | error) {
    return create_dir_mode(path, 0o755);
}

// Create directory with specific permissions
export fn create_dir_mode(path: string, mode: u32):(bool | error) {
    path_cstr := to_c_string(path);
    defer libc.safe_free(path_cstr);
    
    libc.safe_mkdir(path_cstr, mode)?;
    return true;
}

// Create directory and all parent directories (like mkdir -p)
export fn create_dir_all(path: string):(bool | error) {
    // TODO: Implement recursive directory creation
    // For now, just create single directory
    return create_dir(path);
}

// Remove empty directory
export fn remove_dir(path: string):(bool | error) {
    path_cstr := to_c_string(path);
    defer libc.safe_free(path_cstr);
    
    libc.safe_rmdir(path_cstr)?;
    return true;
}

// Read directory entries
// TODO: Implement proper iterator when Vex supports it
export fn read_dir(path: string):(bool | error) {
    path_cstr := to_c_string(path);
    defer libc.safe_free(path_cstr);
    
    dir := libc.safe_opendir(path_cstr)?;
    
    loop {
        entry := libc.safe_readdir(dir);
        
        if entry as usize == 0 {
            break;
        }
        
        // TODO: Process entry and yield it
    }
    
    libc.safe_closedir(dir)?;
    return true;
}

// ============================================================================
// Metadata Operations
// ============================================================================

// Check if path exists
export fn exists(path: string):bool {
    path_cstr := to_c_string(path);
    defer libc.safe_free(path_cstr);
    
    stat_buf := libc.safe_malloc(144);
    
    match stat_buf {
        buf: *byte => {
            result := libc.safe_stat(path_cstr, buf as *libc.stat);
            libc.safe_free(buf);
            
            match result {
                success: i32 => return true,
                err: error => return false,
            }
        },
        err: error => return false,
    }
}

export fn is_dir(path: string): bool {
    meta := metadata(path);
    match meta {
        m: Metadata => return m.is_dir,
        err: error => return false,
    }
}

export fn is_file(path: string): bool {
    meta := metadata(path);
    match meta {
        m: Metadata => return m.is_file,
        err: error => return false,
    }
}

export fn is_symlink(path: string): bool {
    meta := metadata(path);
    match meta {
        m: Metadata => return m.is_symlink,
        err: error => return false,
    }
}

export struct Metadata {
    size: u64,
    is_dir: bool,
    is_file: bool,
    is_symlink: bool,
    permissions: u32,
    modified: i64,
    accessed: i64,
    created: i64,
}

export fn metadata(path: string): (Metadata | error) {
    path_cstr := to_c_string(path);
    defer libc.safe_free(path_cstr);
    
    stat_buf := libc.safe_malloc(144)?;
    defer libc.safe_free(stat_buf);
    
    libc.safe_stat(path_cstr, stat_buf as *libc.stat)?;
    
    mode_ptr := stat_buf as *u32;
    mode := unsafe { *mode_ptr };
    
    size_ptr := (stat_buf as usize + 48) as *u64;
    size := unsafe { *size_ptr };
    
    return Metadata {
        size: size,
        is_dir: (mode & 0o040000) != 0,
        is_file: (mode & 0o100000) != 0,
        is_symlink: (mode & 0o120000) != 0,
        permissions: mode & 0o777,
        modified: 0,
        accessed: 0,
        created: 0,
    };
}

// ============================================================================
// Helper Functions
// ============================================================================

export fn to_c_string(s: string):*byte {
    len := s.len();
    ptr_result := libc.safe_malloc(len + 1);
    
    match ptr_result {
        ptr: *byte => {
            src := s.as_ptr();
            unsafe { libc.memcpy(ptr, src, len); }
            unsafe { *(ptr + len) = 0; }
            return ptr;
        },
        err: error => {
            return 0 as *byte;
        },
    }
}
