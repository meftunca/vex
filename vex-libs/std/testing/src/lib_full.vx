// Testing Module
// Full-featured testing & benchmarking harness (vex_testing.c)
//
// Usage:
//   import { assert, assert_eq, log, skip, bench, set_bytes } from "testing";

// Test function type
type TestFn = fn():None;

// Benchmark result
struct BenchResult {
    n: i64,
    total_ns: u64,
    ns_per_op: f64,
    mb_per_s: f64,
    bytes_per_op: u64,
}

// Reporter types
let REP_TEXT: i32 = 0;
let REP_TAP: i32 = 1;
let REP_JUNIT: i32 = 2;

// External C functions from vex-runtime/c/vex_testing.c
extern "C" {
    // Test assertions & logging
    fn vex_assert(cond: bool, file: *u8, line: i32, msg: *u8);
    fn vex_log(fmt: *u8, ...);
    fn vex_error(fmt: *u8, ...);
    fn vex_fatal(fmt: *u8, ...);
    fn vex_skip(fmt: *u8, ...);
    
    // Subtests
    fn vex_subtest(name: *u8, func: TestFn);
    
    // Benchmarking
    fn vex_bench_set_bytes(bytes_per_op: u64);
    fn vex_bench_reset_timer();
    fn vex_bench_start_timer();
    fn vex_bench_stop_timer();
    
    // Platform optimizations
    fn vex_pin_to_cpu(cpu: i32);
    fn vex_set_realtime_hint();
    
    // Fence/barrier
    fn vex_fence_seqcst();
}

// Assert with custom message
export fn assert(condition: bool, message: string) {
    if !condition {
        unsafe {
            vex_assert(condition, file!().as_ptr(), line!() as i32, message.as_ptr());
        }
    }
}

// Assert equality
export fn assert_eq<T>(left: T, right: T, message: string) {
    if left != right {
        panic(message);
    }
}

// Log message (visible in test output)
export fn log(message: string) {
    unsafe {
        vex_log(message.as_ptr());
    }
}

// Error (non-fatal, marks test as failed)
export fn error(message: string) {
    unsafe {
        vex_error(message.as_ptr());
    }
}

// Fatal error (stops test immediately)
export fn fatal(message: string) {
    unsafe {
        vex_fatal(message.as_ptr());
    }
}

// Skip test with reason
export fn skip(reason: string) {
    unsafe {
        vex_skip(reason.as_ptr());
    }
}

// Run subtest
export fn subtest(name: string, test_fn: TestFn) {
    unsafe {
        vex_subtest(name.as_ptr(), test_fn);
    }
}

// Set bytes per operation (for throughput calculation)
export fn set_bytes(bytes_per_op: u64) {
    unsafe {
        vex_bench_set_bytes(bytes_per_op);
    }
}

// Reset benchmark timer (exclude setup time)
export fn reset_timer() {
    unsafe {
        vex_bench_reset_timer();
    }
}

// Start benchmark timer
export fn start_timer() {
    unsafe {
        vex_bench_start_timer();
    }
}

// Stop benchmark timer
export fn stop_timer() {
    unsafe {
        vex_bench_stop_timer();
    }
}

// Pin to CPU core (Linux only, for stable benchmarks)
export fn pin_to_cpu(cpu: i32) {
    unsafe {
        vex_pin_to_cpu(cpu);
    }
}

// Request realtime priority (Linux only)
export fn set_realtime_hint() {
    unsafe {
        vex_set_realtime_hint();
    }
}

// Memory fence (prevent reordering)
export fn fence() {
    unsafe {
        vex_fence_seqcst();
    }
}

// Helper: Assert with formatted message
export fn assert_fmt(condition: bool, fmt: string, args: ...): bool {
    if !condition {
        let message = format(fmt, args);
        assert(condition, message);
        return false;
    }
    return true;
}

// Helper: Benchmark a function N times
export fn bench_n(name: string, n: i64, func: fn()) {
    reset_timer();
    start_timer();
    
    for i in 0..n {
        func();
    }
    
    stop_timer();
}

// Helper: Table-driven tests
export fn run_table<T>(name: string, cases: &[(string, T, T)], test_fn: fn(T): T) {
    for (case_name, input, expected) in cases {
        subtest(case_name, fn() {
            let result = test_fn(input);
            assert_eq(result, expected, format("Expected {:?}, got {:?}", expected, result));
        });
    }
}

// Helper: Assert no panic (catches panic)
export fn assert_no_panic(func: fn()): bool {
    // TODO: Requires panic catching mechanism
    // For now, just run the function
    func();
    return true;
}

// Helper: Assert panic occurs
export fn assert_panic(func: fn()): bool {
    // TODO: Requires panic catching mechanism
    return false;
}

// ==========================================
// Parallel Testing
// ==========================================

extern "C" fn vex_run_tests_parallel(
    suite_name: *i8,
    tests: *void,
    n_tests: usize,
    fx: *void,
    n_threads: i32
): i32;

// Run tests in parallel with N threads
// Use n_threads = 0 for auto-detection (CPU count)
export fn run_parallel(suite_name: string, n_threads: i32): i32 {
    unsafe {
        vex_run_tests_parallel(
            suite_name.as_ptr() as *i8,
            null(),  // TODO: Pass test cases
            0,
            null(),
            n_threads
        )
    }
}

// ==========================================
// Property-Based Testing (QuickCheck-style)
// ==========================================

extern "C" {
    type vex_property_ctx;
    
    fn vex_property_init(seed: u64, max_tests: usize): vex_property_ctx;
    fn vex_gen_i64(ctx: &vex_property_ctx!, min: i64, max: i64): i64;
    fn vex_gen_f64(ctx: &vex_property_ctx!, min: f64, max: f64): f64;
    fn vex_gen_bool(ctx: &vex_property_ctx!): bool;
}

// Property test context
export struct PropertyCtx {
    ctx: vex_property_ctx,
}

export fn property_init(seed: u64, max_tests: usize): PropertyCtx {
    unsafe {
        PropertyCtx { ctx: vex_property_init(seed, max_tests) }
    }
}

// Random generators
export fn gen_i64(ctx: &PropertyCtx!, min: i64, max: i64): i64 {
    unsafe {
        vex_gen_i64(&ctx.ctx!, min, max)
    }
}

export fn gen_f64(ctx: &PropertyCtx!, min: f64, max: f64): f64 {
    unsafe {
        vex_gen_f64(&ctx.ctx!, min, max)
    }
}

export fn gen_bool(ctx: &PropertyCtx!): bool {
    unsafe {
        vex_gen_bool(&ctx.ctx!)
    }
}

// ==========================================
// Fuzzing Support
// ==========================================

extern "C" {
    fn vex_fuzz_consume_i64(data: &*u8!, size: &usize!): i64;
    fn vex_fuzz_consume_bytes(data: &*u8!, size: &usize!, n: usize): *u8;
    fn vex_fuzz_consume_str(data: &*u8!, size: &usize!, max_len: usize): *i8;
}

// Fuzz input helpers
export fn fuzz_consume_i64(data: &*u8!, size: &usize!): i64 {
    unsafe {
        vex_fuzz_consume_i64(data, size)
    }
}

export fn fuzz_consume_bytes(data: &*u8!, size: &usize!, n: usize): &[u8] {
    unsafe {
        let ptr = vex_fuzz_consume_bytes(data, size, n);
        if ptr == null() {
            return &[];
        }
        // TODO: Convert to slice
        &[]
    }
}

export fn fuzz_consume_str(data: &*u8!, size: &usize!, max_len: usize): string {
    unsafe {
        let ptr = vex_fuzz_consume_str(data, size, max_len);
        if ptr == null() {
            return "";
        }
        string.from_raw(ptr)
    }
}

