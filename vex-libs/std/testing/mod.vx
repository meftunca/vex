// std.testing - Layer 2: Testing Framework (100% Safe Native Vex)
// Built-in test framework inspired by Go's testing package

export struct TestContext {
    name: string,
    failed: bool,
    logs: [string],
}

// Create new test context
export fn new_test(name: string) : TestContext {
    return TestContext {
        name: name,
        failed: false,
        logs: [],
    };
}

// Mark test as failed with message
export fn (t: &TestContext) fail(message: string) {
    t.failed = true;
    t.logs.push(f"FAIL: {message}");
}

// Log a message
export fn (t: &TestContext) log(message: string) {
    t.logs.push(message);
}

// Assert equality
export fn (t: &TestContext) assert_eq<T>(actual: T, expected: T, message: string) {
    if actual != expected {
        t.fail(f"{message}: expected {expected}, got {actual}");
    }
}

// Assert true
export fn (t: &TestContext) assert(condition: bool, message: string) {
    if !condition {
        t.fail(message);
    }
}

// Assert not equal
export fn (t: &TestContext) assert_ne<T>(actual: T, expected: T, message: string) {
    if actual == expected {
        t.fail(f"{message}: expected not equal to {expected}");
    }
}

// Run a single test
export fn run_test(name: string, test_fn: fn(&TestContext)) : bool {
    ctx := new_test(name);
    
    print(f"Running test: {name}");
    test_fn(&ctx);
    
    if ctx.failed {
        print(f"❌ FAILED: {name}");
        for log in ctx.logs {
            print(f"  {log}");
        }
        return false;
    } else {
        print(f"✅ PASSED: {name}");
        return true;
    }
}

// Test suite
export struct TestSuite {
    name: string,
    tests: [(string, fn(&TestContext))],
}

// Create new test suite
export fn new_suite(name: string) : TestSuite {
    return TestSuite {
        name: name,
        tests: [],
    };
}

// Add test to suite
export fn (s: &TestSuite) add_test(name: string, test_fn: fn(&TestContext)) {
    s.tests.push((name, test_fn));
}

// Run all tests in suite
export fn (s: &TestSuite) run() : (i32, i32) {
    print(f"\n=== Test Suite: {s.name} ===");
    
    passed := 0;
    failed := 0;
    
    for (test_name, test_fn) in s.tests {
        if run_test(test_name, test_fn) {
            passed = passed + 1;
        } else {
            failed = failed + 1;
        }
    }
    
    print(f"\n=== Results ===");
    print(f"Passed: {passed}");
    print(f"Failed: {failed}");
    print(f"Total:  {passed + failed}");
    
    return (passed, failed);
}

// Benchmark context
export struct BenchContext {
    name: string,
    iterations: i32,
    start_time: i64,
    end_time: i64,
}

// Run benchmark
export fn benchmark(name: string, iterations: i32, bench_fn: fn()) {
    print(f"Running benchmark: {name} ({iterations} iterations)");
    
    start := get_time_ns();
    
    for i := 0; i < iterations; i++ {
        bench_fn();
    }
    
    end := get_time_ns();
    duration_ns := end - start;
    ns_per_op := duration_ns / iterations;
    
    print(f"  {ns_per_op} ns/op");
    print(f"  {iterations * 1000000000 / duration_ns} ops/sec");
}

// Get current time in nanoseconds
export fn get_time_ns() : i64 {
    // This would call __runtime_get_time intrinsic
    return 0; // Placeholder
}

// Example usage:
// 
// fn test_addition(t: &TestContext) {
//     t.assert_eq(2 + 2, 4, "addition works");
// }
//
// fn main() : i32 {
//     suite := testing.new_suite("Math Tests");
//     suite.add_test("addition", test_addition);
//     let (passed, failed) = suite.run();
//     return if failed > 0 { 1 } else { 0 };
// }
