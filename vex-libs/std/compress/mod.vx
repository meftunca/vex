// std.compress - Compression utilities (High-level)
// Wrappers around zlib, zstd, and lz4

import { zlib, zstd, lz4 } from "../ffi";

// ============================================================================
// Zlib Compression (gzip, deflate)
// ============================================================================

// Compress data using zlib (deflate algorithm)
export fn compress_zlib(data: &[byte], level: i32):([byte] | error) {
    // Estimate compressed size (worst case: input + 0.1% + 12 bytes)
    max_size := data.len() + (data.len() / 1000) + 12;
    compressed := make([byte], max_size);
    
    compressed_len := max_size as u64;
    
    // Validate compression level (0-9)
    compression_level := if level < 0 { 6 } else if level > 9 { 9 } else { level };
    
    result := unsafe {
        zlib.compress2(
            compressed.as_mut_ptr(),
            &compressed_len,
            data.as_ptr(),
            data.len() as u64,
            compression_level
        )
    };
    
    if result != zlib.Z_OK {
        return error.new("Zlib compression failed");
    }
    
    // Resize to actual compressed size
    compressed.resize(compressed_len as usize);
    return compressed;
}

// Decompress zlib data
export fn decompress_zlib(data: &[byte]):([byte] | error) {
    // Start with 4x input size, grow if needed
    decompressed_size := data.len() * 4;
    decompressed := make([byte], decompressed_size);
    
    actual_size := decompressed_size as u64;
    
    result := unsafe {
        zlib.uncompress(
            decompressed.as_mut_ptr(),
            &actual_size,
            data.as_ptr(),
            data.len() as u64
        )
    };
    
    if result == zlib.Z_BUF_ERROR {
        // Buffer too small, try with 10x size
        decompressed_size = data.len() * 10;
        decompressed2 := make([byte], decompressed_size);
        actual_size = decompressed_size as u64;
        
        result2 := unsafe {
            zlib.uncompress(
                decompressed2.as_mut_ptr(),
                &actual_size,
                data.as_ptr(),
                data.len() as u64
            )
        };
        
        if result2 != zlib.Z_OK {
            return error.new("Zlib decompression failed");
        }
        
        decompressed2.resize(actual_size as usize);
        return decompressed2;
    } else if result != zlib.Z_OK {
        return error.new("Zlib decompression failed");
    }
    
    decompressed.resize(actual_size as usize);
    return decompressed;
}

// ============================================================================
// Zstandard Compression (zstd)
// ============================================================================

// Compress data using Zstandard
export fn compress_zstd(data: &[byte], level: i32):([byte] | error) {
    // Get maximum compressed size
    max_size := unsafe { zstd.ZSTD_compressBound(data.len() as u64) } as usize;
    compressed := make([byte], max_size);
    
    // Validate compression level (1-22, default 3)
    compression_level := if level < 1 { 3 } else if level > 22 { 22 } else { level };
    
    compressed_size := unsafe {
        zstd.ZSTD_compress(
            compressed.as_mut_ptr() as *byte,
            max_size as u64,
            data.as_ptr() as *byte,
            data.len() as u64,
            compression_level
        )
    };
    
    // Check for error
    is_error := unsafe { zstd.ZSTD_isError(compressed_size) };
    if is_error != 0 {
        return error.new("Zstd compression failed");
    }
    
    compressed.resize(compressed_size as usize);
    return compressed;
}

// Decompress Zstandard data
export fn decompress_zstd(data: &[byte]):([byte] | error) {
    // Get decompressed size from frame header
    decompressed_size := unsafe {
        zstd.ZSTD_getFrameContentSize(data.as_ptr() as *byte, data.len() as u64)
    };
    
    // Check for error or unknown size
    if decompressed_size == zstd.ZSTD_CONTENTSIZE_ERROR {
        return error.new("Invalid zstd frame header");
    }
    
    // If size unknown, use heuristic
    buffer_size := if decompressed_size == zstd.ZSTD_CONTENTSIZE_UNKNOWN {
        data.len() * 4
    } else {
        decompressed_size as usize
    };
    
    decompressed := make([byte], buffer_size);
    
    actual_size := unsafe {
        zstd.ZSTD_decompress(
            decompressed.as_mut_ptr() as *byte,
            buffer_size as u64,
            data.as_ptr() as *byte,
            data.len() as u64
        )
    };
    
    is_error := unsafe { zstd.ZSTD_isError(actual_size) };
    if is_error != 0 {
        return error.new("Zstd decompression failed");
    }
    
    decompressed.resize(actual_size as usize);
    return decompressed;
}

// ============================================================================
// LZ4 Compression (fast compression)
// ============================================================================

// Compress data using LZ4
export fn compress_lz4(data: &[byte]):([byte] | error) {
    // Get maximum compressed size
    max_size := unsafe { lz4.LZ4_compressBound(data.len() as i32) } as usize;
    
    if max_size == 0 {
        return error.new("Input too large for LZ4");
    }
    
    compressed := make([byte], max_size);
    
    compressed_size := unsafe {
        lz4.LZ4_compress_default(
            data.as_ptr() as *byte,
            compressed.as_mut_ptr() as *byte,
            data.len() as i32,
            max_size as i32
        )
    };
    
    if compressed_size <= 0 {
        return error.new("LZ4 compression failed");
    }
    
    compressed.resize(compressed_size as usize);
    return compressed;
}

// Decompress LZ4 data (requires original size)
export fn decompress_lz4(data: &[byte], original_size: usize):([byte] | error) {
    decompressed := make([byte], original_size);
    
    result := unsafe {
        lz4.LZ4_decompress_safe(
            data.as_ptr() as *byte,
            decompressed.as_mut_ptr() as *byte,
            data.len() as i32,
            original_size as i32
        )
    };
    
    if result < 0 {
        return error.new("LZ4 decompression failed");
    }
    
    return decompressed;
}

// LZ4 High Compression (slower but better ratio)
export fn compress_lz4_hc(data: &[byte], level: i32):([byte] | error) {
    max_size := unsafe { lz4.LZ4_compressBound(data.len() as i32) } as usize;
    
    if max_size == 0 {
        return error.new("Input too large for LZ4");
    }
    
    compressed := make([byte], max_size);
    
    // LZ4 HC levels: 1-12 (higher = better compression, slower)
    compression_level := if level < 1 { 9 } else if level > 12 { 12 } else { level };
    
    compressed_size := unsafe {
        lz4.LZ4_compress_HC(
            data.as_ptr() as *byte,
            compressed.as_mut_ptr() as *byte,
            data.len() as i32,
            max_size as i32,
            compression_level
        )
    };
    
    if compressed_size <= 0 {
        return error.new("LZ4 HC compression failed");
    }
    
    compressed.resize(compressed_size as usize);
    return compressed;
}

// ============================================================================
// Convenience Functions
// ============================================================================

// Compression level presets
export const COMPRESS_LEVEL_FAST: i32 = 1;
export const COMPRESS_LEVEL_DEFAULT: i32 = 6;
export const COMPRESS_LEVEL_BEST: i32 = 9;

// Auto-detect compression algorithm and decompress
export fn decompress_auto(data: &[byte]):([byte] | error) {
    // Check magic bytes
    if data.len() < 4 {
        return error.new("Data too short");
    }
    
    // Zlib: 0x78 0x9C (default compression)
    if data[0] == 0x78 && (data[1] == 0x9C || data[1] == 0x01 || data[1] == 0xDA) {
        return decompress_zlib(data);
    }
    
    // Zstd: 0x28 0xB5 0x2F 0xFD
    if data[0] == 0x28 && data[1] == 0xB5 && data[2] == 0x2F && data[3] == 0xFD {
        return decompress_zstd(data);
    }
    
    // LZ4: No standard magic bytes, try decompression with heuristic size
    // This is unreliable without size metadata
    return error.new("Unknown compression format");
}
