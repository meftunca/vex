// Core Module
// Essential types and contracts: Box, Vec, Option, Result, Drop, Clone, Eq, Ord, Iterator
//
// Usage:
//   import { Box, Vec, Option, Result, Drop, Clone, Eq, Ord, Iterator } from "core";

// ===== Core contracts =====

// Drop contract - Automatic cleanup on scope exit (RAII pattern)
// Types implementing Drop will have drop() called automatically when going out of scope
export contract Drop {
    fn drop();  // Called automatically, no parameters
}

// Clone contract - Explicit deep copying
// Types implementing Clone can be duplicated with .clone()
export contract Clone {
    fn clone(): Self;  // Returns a copy of self
}

// Eq contract - Equality comparison
// Types implementing Eq can be compared for equality
export contract Eq {
    fn equals(other: Self): bool;  // Returns true if self == other
}

// Ord contract - Ordering comparison
// Types implementing Ord can be compared for ordering
export contract Ord {
    fn compare(other: Self): i32;  // Returns -1 (less), 0 (equal), 1 (greater)
}

// Iterator contract - Iteration over sequences
// Types implementing Iterator can be iterated with for-in loops
export contract Iterator {
    type Item;  // Associated type for elements
    
    fn next()!: Option<i32>;  // Returns next element or None (mutable) - TEMPORARY: use i32 instead of Self.Item
}

// Display contract - String representation for debugging and display
// Types implementing Display can be converted to string for printing
export contract Display {
    fn to_string(): string;  // Returns string representation of self
}

// ===== External C functions =====

extern "C" {
    // Box operations
    fn vex_box_new(value: *u8, size: u64): *u8;
    fn vex_box_free(box_ptr: *u8);
    fn vex_box_unbox(box_ptr: *u8): *u8;
    fn vex_box_clone(box_ptr: *u8): *u8;
    
    // Vec operations
    fn vex_vec_new(elem_size: u64): *u8;
    fn vex_vec_push(vec_ptr: *u8, elem: *u8);
    fn vex_vec_get(vec_ptr: *u8, index: u64): *u8;
    fn vex_vec_len(vec_ptr: *u8): u64;
    fn vex_vec_free(vec_ptr: *u8);
}

// Box<T> - Heap-allocated single value
export struct Box<T> {
    ptr: *u8,
}

// Vec<T> - Dynamic array
export struct Vec<T> {
    ptr: *u8,
}

// Option<T> - Optional value
export enum Option<T> {
    Some(T),
    None,
}

// Result<T, E> - Success or error
export enum Result<T, E> {
    Ok(T),
    Err(E),
}

