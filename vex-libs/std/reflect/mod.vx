// Vex Standard Library - Reflection Module
// Runtime type information and introspection

// Get type name as string
export fn type_name<T>(value: T): string {
    return typeof(value);
}

// Get unique type identifier
export fn type_id<T>(value: T): i64 {
    return type_id(value);
}

// Get type size in bytes (compile-time constant)
export fn size_of<T>(value: T): i64 {
    return sizeof(value);
}

// Get type alignment in bytes (compile-time constant)
export fn align_of<T>(value: T): i64 {
    return alignof(value);
}

// Type checks

export fn is_integer<T>(value: T): bool {
    return is_int_type(value);
}

export fn is_float<T>(value: T): bool {
    return is_float_type(value);
}

export fn is_pointer<T>(value: T): bool {
    return is_pointer_type(value);
}

// Helper functions

// Check if types are the same
export fn same_type<T, U>(a: T, b: U): bool {
    return type_id(a) == type_id(b);
}

// Print type information
export fn print_type_info<T>(value: T) {
    println("Type Information:");
    print("  Name: ");
    println(typeof(value));
    print("  ID: ");
    println(type_id(value));
    print("  Size: ");
    println(sizeof(value));
    print("  Align: ");
    println(alignof(value));
    print("  Integer: ");
    println(is_int_type(value));
    print("  Float: ");
    println(is_float_type(value));
    print("  Pointer: ");
    println(is_pointer_type(value));
}

// Example usage:
// let x: i32 = 42;
// let y: f64 = 3.14;
// 
// println(reflect.type_name(x));        // "i32"
// println(reflect.type_name(y));        // "f64"
// 
// println(reflect.size_of(x));          // 4
// println(reflect.size_of(y));          // 8
// 
// if reflect.is_integer(x) {
//     println("x is an integer");
// }
//
// if reflect.same_type(x, 100) {
//     println("Same type!");
// }
//
// struct Point { x: i32, y: i32 }
// let p = Point { x: 10, y: 20 };
// println(reflect.type_name(p));        // "Point"
// println(reflect.size_of(p));          // 8
