// encoding/src/lib.vx - High-performance encoding utilities
// Provides Base16 (Hex), Base64, and UUID generation/parsing

import { 
    vex_hex_encoded_len, vex_hex_encode, vex_hex_decode,
    vex_base64_encoded_len, vex_base64_encode, vex_base64_decode,
    vex_uuid_v4, vex_uuid_format, vex_uuid_parse
} from "./extern.vxc";

// ===== Hex Encoding =====

export fn hex_encode(data: String, uppercase: bool) : String {
    let bytes = data.as_bytes();
    let len = data.len();
    let encoded_len = vex_hex_encoded_len(len);
    
    // Allocate output buffer
    let out_buf = Vec<u8>.with_capacity(encoded_len);
    let out_ptr = out_buf.as_mut_ptr();
    
    // Encode
    let upper_flag = if uppercase { 1 } else { 0 };
    let actual_len = vex_hex_encode(bytes, len, out_ptr, upper_flag);
    
    // Create string from buffer
    out_buf.set_len(actual_len);
    return String.from_utf8_unchecked(out_buf);
}

export fn hex_decode(encoded: String) : Result<String, String> {
    let bytes = encoded.as_bytes();
    let len = encoded.len();
    let decoded_len = vex_hex_decoded_len(len);
    
    // Allocate output buffer
    let out_buf = Vec<u8>.with_capacity(decoded_len);
    let out_ptr = out_buf.as_mut_ptr();
    
    // Decode
    let actual_len = vex_hex_decode(bytes, len, out_ptr);
    
    if actual_len < 0 {
        return Err("Invalid hex encoding");
    }
    
    out_buf.set_len(actual_len);
    return Ok(String.from_utf8_unchecked(out_buf));
}

// ===== Base64 Encoding =====

export enum Base64Alphabet {
    Standard,    // A-Z a-z 0-9 + /
    UrlSafe      // A-Z a-z 0-9 - _
}

export struct Base64Config {
    alphabet: Base64Alphabet,
    padding: bool,
    wrap: i64    // 0 = no wrap, 76 = MIME wrap
}

export fn base64_encode(data: String, config: Base64Config) : String {
    let bytes = data.as_bytes();
    let len = data.len();
    
    let alpha_int = match config.alphabet {
        Base64Alphabet.Standard => 0,
        Base64Alphabet.UrlSafe => 1
    };
    let pad_int = if config.padding { 1 } else { 0 };
    
    let encoded_len = vex_base64_encoded_len(len, alpha_int, pad_int, config.wrap);
    
    let out_buf = Vec<u8>.with_capacity(encoded_len);
    let out_ptr = out_buf.as_mut_ptr();
    
    let actual_len = vex_base64_encode(bytes, len, out_ptr, alpha_int, pad_int, config.wrap);
    
    out_buf.set_len(actual_len);
    return String.from_utf8_unchecked(out_buf);
}

export fn base64_decode(encoded: String, alphabet: Base64Alphabet) : Result<String, String> {
    let bytes = encoded.as_bytes();
    let len = encoded.len();
    
    let alpha_int = match alphabet {
        Base64Alphabet.Standard => 0,
        Base64Alphabet.UrlSafe => 1
    };
    
    let max_len = vex_base64_max_decoded_len(len);
    
    let out_buf = Vec<u8>.with_capacity(max_len);
    let out_ptr = out_buf.as_mut_ptr();
    
    let actual_len = vex_base64_decode(bytes, len, out_ptr, alpha_int);
    
    if actual_len < 0 {
        return Err("Invalid base64 encoding");
    }
    
    out_buf.set_len(actual_len);
    return Ok(String.from_utf8_unchecked(out_buf));
}

// ===== UUID =====

export struct UUID {
    bytes: [u8; 16]
}

export fn uuid_v4() : Result<UUID, String> {
    let mut uuid = UUID { bytes: [0; 16] };
    let result = vex_uuid_v4(&mut uuid.bytes as *u8);
    if result != 0 {
        return Err("Failed to generate UUID v4");
    }
    return Ok(uuid);
}

export fn uuid_format(uuid: UUID) : String {
    let mut out_buf: [u8; 37] = [0; 37];
    vex_uuid_format(&mut out_buf as *u8, &uuid.bytes as *u8);
    
    // Convert to string (36 chars + null terminator)
    let result = Vec<u8>.with_capacity(36);
    let result_ptr = result.as_mut_ptr();
    
    // Copy 36 bytes (exclude null terminator)
    for i in 0..36 {
        *((result_ptr as i64 + i) as *u8) = out_buf[i];
    }
    
    result.set_len(36);
    return String.from_utf8_unchecked(result);
}

export fn uuid_parse(s: String) : Result<UUID, String> {
    let mut uuid = UUID { bytes: [0; 16] };
    let bytes = s.as_bytes();
    let result = vex_uuid_parse(bytes, &mut uuid.bytes as *u8);
    if result != 0 {
        return Err("Invalid UUID format");
    }
    return Ok(uuid);
}


