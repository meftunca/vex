// Encoding Module
// Base64, Base32, Hex, UUID encoding/decoding (vex_fastenc)
//
// Usage:
//   import { base64_encode, hex_decode, uuid_v4, uuid_v7 } from "encoding";

// External C functions from vex-runtime/c/vex_fastenc/
extern "C" {
    // UUID type
    struct vex_uuid {
        bytes: [u8; 16],
    }
    
    // Base64 config
    struct vex_b64_cfg {
        alpha: i32,  // 0=std, 1=urlsafe
        pad: i32,    // padding enabled
        wrap: i32,   // wrap column
    }
    
    // Base32 config
    struct vex_b32_cfg {
        alpha: i32,  // 0=RFC, 1=HEX, 2=Crockford
        pad: i32,    // padding
    }
    
    // Hex
    fn vex_hex_encode(src: *u8, n: u64, dst: *u8!, uppercase: i32): u64;
    fn vex_hex_decode(src: *u8, n: u64, dst: *u8!): i64;
    fn vex_hex_encoded_len(nbytes: u64): u64;
    fn vex_hex_decoded_len(nchars: u64): u64;
    
    // Base64
    fn vex_base64_encode(src: *u8, n: u64, dst: *u8!, cfg: vex_b64_cfg): u64;
    fn vex_base64_decode(src: *u8, n: u64, dst: *u8!, alpha: i32): i64;
    fn vex_base64_encoded_len(nbytes: u64, cfg: vex_b64_cfg): u64;
    fn vex_base64_max_decoded_len(nchars: u64): u64;
    
    // Base32
    fn vex_base32_encode(src: *u8, n: u64, dst: *u8!, cfg: vex_b32_cfg): u64;
    fn vex_base32_decode(src: *u8, n: u64, dst: *u8!, alpha: i32): i64;
    fn vex_base32_encoded_len(nbytes: u64, cfg: vex_b32_cfg): u64;
    fn vex_base32_max_decoded_len(nchars: u64): u64;
    
    // UUID
    fn vex_uuid_v1(out: *vex_uuid): i32;
    fn vex_uuid_v3(out: *vex_uuid, ns: *const vex_uuid, name: *u8, len: u64): i32;
    fn vex_uuid_v4(out: *vex_uuid): i32;
    fn vex_uuid_v5(out: *vex_uuid, ns: *const vex_uuid, name: *u8, len: u64): i32;
    fn vex_uuid_v6(out: *vex_uuid): i32;
    fn vex_uuid_v7(out: *vex_uuid): i32;
    fn vex_uuid_v8(out: *vex_uuid, custom: *u8): i32;
    fn vex_uuid_format(out: *u8!, u: *const vex_uuid): i32;  // 37 bytes (36 + null)
    fn vex_uuid_parse(s: *u8, out: *vex_uuid): i32;
}

// UUID wrapper
export struct UUID {
    bytes: [u8; 16],
}

// Hex encode
export fn hex_encode(data: &[u8], uppercase: bool): string {
    let out_len = unsafe { vex_hex_encoded_len(data.len()) };
    let! buf: Vec<u8> = Vec.with_capacity(out_len);
    unsafe {
        vex_hex_encode(data.as_ptr(), data.len(), buf.as_mut_ptr(), if uppercase { 1 } else { 0 });
        buf.set_len(out_len);
    }
    return string.from_utf8_unchecked(buf);
}

// Hex decode
export fn hex_decode(s: string): Vec<u8> {
    let out_len = unsafe { vex_hex_decoded_len(s.len()) };
    let! buf: Vec<u8> = Vec.with_capacity(out_len);
    unsafe {
        let written = vex_hex_decode(s.as_ptr(), s.len(), buf.as_mut_ptr());
        if written < 0 {
            panic("Invalid hex string");
        }
        buf.set_len(written as u64);
    }
    return buf;
}

// Base64 encode (standard)
export fn base64_encode(data: &[u8]): string {
    let cfg = vex_b64_cfg { alpha: 0, pad: 1, wrap: 0 };
    let out_len = unsafe { vex_base64_encoded_len(data.len(), cfg) };
    let! buf: Vec<u8> = Vec.with_capacity(out_len);
    unsafe {
        vex_base64_encode(data.as_ptr(), data.len(), buf.as_mut_ptr(), cfg);
        buf.set_len(out_len);
    }
    return string.from_utf8_unchecked(buf);
}

// Base64 decode
export fn base64_decode(s: string): Vec<u8> {
    let out_len = unsafe { vex_base64_max_decoded_len(s.len()) };
    let! buf: Vec<u8> = Vec.with_capacity(out_len);
    unsafe {
        let written = vex_base64_decode(s.as_ptr(), s.len(), buf.as_mut_ptr(), 0);
        if written < 0 {
            panic("Invalid base64 string");
        }
        buf.set_len(written as u64);
    }
    return buf;
}

// Base32 encode (RFC 4648)
export fn base32_encode(data: &[u8]): string {
    let cfg = vex_b32_cfg { alpha: 0, pad: 1 };
    let out_len = unsafe { vex_base32_encoded_len(data.len(), cfg) };
    let! buf: Vec<u8> = Vec.with_capacity(out_len);
    unsafe {
        vex_base32_encode(data.as_ptr(), data.len(), buf.as_mut_ptr(), cfg);
        buf.set_len(out_len);
    }
    return string.from_utf8_unchecked(buf);
}

// Base32 decode
export fn base32_decode(s: string): Vec<u8> {
    let out_len = unsafe { vex_base32_max_decoded_len(s.len()) };
    let! buf: Vec<u8> = Vec.with_capacity(out_len);
    unsafe {
        let written = vex_base32_decode(s.as_ptr(), s.len(), buf.as_mut_ptr(), 0);
        if written < 0 {
            panic("Invalid base32 string");
        }
        buf.set_len(written as u64);
    }
    return buf;
}

// Generate UUID v4 (random)
export fn uuid_v4(): UUID {
    let! u: vex_uuid;
    unsafe {
        vex_uuid_v4(&u);
    }
    return UUID { bytes: u.bytes };
}

// Generate UUID v7 (time-based, sortable)
export fn uuid_v7(): UUID {
    let! u: vex_uuid;
    unsafe {
        vex_uuid_v7(&u);
    }
    return UUID { bytes: u.bytes };
}

// Format UUID to string
export fn uuid_format(u: UUID): string {
    let! buf: [u8; 37];
    unsafe {
        vex_uuid_format(buf.as_mut_ptr(), &u as *const vex_uuid);
        return string.from_utf8_unchecked(&buf[0..36]);
    }
}

// Parse UUID from string
export fn uuid_parse(s: string): UUID {
    let! u: vex_uuid;
    unsafe {
        let result = vex_uuid_parse(s.as_ptr(), &u);
        if result != 0 {
            panic("Invalid UUID string");
        }
    }
    return UUID { bytes: u.bytes };
}

