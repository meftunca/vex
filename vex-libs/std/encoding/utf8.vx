// std::encoding::utf8 - UTF-8 utilities with SIMD optimization (20GB/s)

import { simdutf } from "../../ffi";

// ============================================================================
// Validation
// ============================================================================

// Validate UTF-8 string (SIMD optimized, 20GB/s)
fn is_valid_utf8(data: &[byte]): bool {
    return simdutf.vex_utf8_validate(data.as_ptr(), data.len());
}

// Validate UTF-8 with error position
fn validate_utf8_with_errors(data: &[byte]): (bool, usize) {
    error_pos: usize = 0;
    valid := simdutf.vex_utf8_validate_with_errors(
        data.as_ptr(),
        data.len(),
        &error_pos
    );
    return (valid, error_pos);
}

// Check if string is pure ASCII
fn is_ascii(data: &[byte]): bool {
    return simdutf.vex_is_ascii(data.as_ptr(), data.len());
}

// ============================================================================
// Character Operations
// ============================================================================

// Count Unicode characters (not bytes!)
fn char_count(s: string): usize {
    bytes := s.as_bytes();
    return simdutf.vex_utf8_count_chars(bytes.as_ptr(), bytes.len());
}

// Get character at index
fn char_at(s: string, index: usize): (char | error) {
    bytes := s.as_bytes();
    codepoint := simdutf.vex_utf8_char_at(bytes.as_ptr(), bytes.len(), index);
    
    if codepoint == 0xFFFFFFFF {
        return error.new("Invalid index or UTF-8");
    }
    
    // Convert u32 to char
    return codepoint as char;
}

// ============================================================================
// UTF-8 â†” UTF-16 Conversion (SIMD optimized)
// ============================================================================

// Convert UTF-8 to UTF-16 Little Endian
fn to_utf16(s: string): [u16] {
    bytes := s.as_bytes();
    
    // Get required buffer size
    utf16_len := simdutf.vex_utf8_to_utf16_length(bytes.as_ptr(), bytes.len());
    
    if utf16_len == 0 {
        return [];
    }
    
    // Allocate buffer
    utf16 := make([u16], utf16_len);
    
    // Convert
    written := simdutf.vex_utf8_to_utf16(
        bytes.as_ptr(),
        bytes.len(),
        utf16.as_ptr(),
        utf16_len
    );
    
    if written == 0 {
        return [];  // Conversion failed
    }
    
    return utf16;
}

// Convert UTF-16 LE to UTF-8 string
fn from_utf16(utf16: &[u16]): (string | error) {
    // Validate UTF-16
    if !simdutf.vex_utf16_validate(utf16.as_ptr(), utf16.len()) {
        return error.new("Invalid UTF-16");
    }
    
    // Get required buffer size
    utf8_len := simdutf.vex_utf16_to_utf8_length(utf16.as_ptr(), utf16.len());
    
    if utf8_len == 0 {
        return "";
    }
    
    // Allocate buffer
    utf8_bytes := make([byte], utf8_len);
    
    // Convert
    written := simdutf.vex_utf16_to_utf8(
        utf16.as_ptr(),
        utf16.len(),
        utf8_bytes.as_ptr(),
        utf8_len
    );
    
    if written == 0 {
        return error.new("UTF-16 to UTF-8 conversion failed");
    }
    
    // Convert bytes to string
    // TODO: Need string.from_bytes() or similar
    return "";  // Placeholder
}

// ============================================================================
// Encoding Detection
// ============================================================================

// Detect possible encodings
fn detect_encoding(data: &[byte]): EncodingFlags {
    flags := simdutf.vex_detect_encoding(data.as_ptr(), data.len());
    return EncodingFlags { bits: flags };
}

struct EncodingFlags {
    bits: i32,
}

fn (e: &EncodingFlags) is_utf8(): bool {
    return (e.bits & simdutf.SIMDUTF_ENCODING_UTF8) != 0;
}

fn (e: &EncodingFlags) is_utf16_le(): bool {
    return (e.bits & simdutf.SIMDUTF_ENCODING_UTF16_LE) != 0;
}

fn (e: &EncodingFlags) is_utf16_be(): bool {
    return (e.bits & simdutf.SIMDUTF_ENCODING_UTF16_BE) != 0;
}

// ============================================================================
// Windows Interop (UTF-16 LE)
// ============================================================================

// Convert to Windows wide string (UTF-16 LE)
fn to_wide_string(s: string): [u16] {
    return to_utf16(s);
}

// Convert from Windows wide string
fn from_wide_string(wide: &[u16]): (string | error) {
    return from_utf16(wide);
}

// ============================================================================
// Example Usage
// ============================================================================

/*
import { utf8 } from "std::encoding";

fn main() {
    text := "Hello, ä¸–ç•Œ! ðŸš€";
    
    // Validate
    if utf8::is_valid_utf8(text.as_bytes()) {
        println("Valid UTF-8!");
    }
    
    // Count characters (not bytes)
    char_count := utf8::char_count(text);  // 13 characters
    byte_count := text.len();               // 18 bytes
    println(f"Characters: {char_count}, Bytes: {byte_count}");
    
    // Get character at index
    ch := utf8::char_at(text, 7)?;  // 'ä¸–'
    
    // Convert to UTF-16 for Windows API
    wide := utf8::to_wide_string(text);
    
    // Detect encoding
    encoding := utf8::detect_encoding(text.as_bytes());
    if encoding.is_utf8() {
        println("Detected UTF-8!");
    }
}
*/
