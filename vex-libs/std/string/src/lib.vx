// String Module
// String operations and UTF-8 validation (Go-like API)
//
// Usage:
//   import { len, compare, contains, has_prefix, to_upper } from "string";

import {
    vex_strlen,
    vex_strcmp,
    vex_strncmp,
    vex_utf8_valid,
    vex_utf8_char_count,
    vex_strdup,
    vex_strcat,
    vex_strcpy,
    vex_str_contains,
    vex_str_has_prefix,
    vex_str_has_suffix,
    vex_str_to_upper,
    vex_str_to_lower,
    vex_str_trim,
    vex_str_replace
} from "./native.vxc";
// ============================================================================
// STRING CREATION AND CONVERSION
// ============================================================================

export fn from_utf8(bytes: *u8, len: u64): Result<str, str> {
    if vex_utf8_valid(bytes, len) {
        // Use from_utf8_unchecked since validation passed
        let s = from_utf8_unchecked(bytes, len);
        return Result.Ok(s);
    } else {
        return Result.Err("Invalid UTF-8 byte sequence");
    }
}

export fn from_utf8_unchecked(bytes: *u8, len: u64): str {
    // Create string from raw bytes without validation
    // bytes is already a *u8, just cast to string
    return bytes;
}

export fn from_cstr(cstr: *u8): str {
    // C strings are null-terminated, just return pointer as string
    // Vex strings are compatible with C strings (both *u8)
    return cstr;
}

export fn len(s: str): u64 {
    let ptr: *u8 = s as *u8;
    return vex_strlen(ptr);
}

export fn compare(s1: str, s2: str): i32 {
    let ptr1: *u8 = s1 as *u8;
    let ptr2: *u8 = s2 as *u8;
    return vex_strcmp(ptr1, ptr2);
}

export fn is_valid_utf8(s: str): bool {
    let ptr: *u8 = s as *u8;
    let length: u64 = len(s);
    return vex_utf8_valid(ptr, length);
}

export fn char_count(s: str): u64 {
    let ptr: *u8 = s as *u8;
    let length: u64 = len(s);
    return vex_utf8_char_count(ptr, length);
}

// ============================================================================
// GO-LIKE STRING OPERATIONS
// ============================================================================

export fn contains(s: str, substr: str): bool {
    let s_ptr: *u8 = s as *u8;
    let substr_ptr: *u8 = substr as *u8;
    return vex_str_contains(s_ptr, substr_ptr);
}

export fn has_prefix(s: str, prefix: str): bool {
    let s_ptr: *u8 = s as *u8;
    let prefix_ptr: *u8 = prefix as *u8;
    return vex_str_has_prefix(s_ptr, prefix_ptr);
}

export fn has_suffix(s: String, suffix: String): bool {
    let s_ptr: *u8 = &s;
    let suffix_ptr: *u8 = &suffix;
    return vex_str_has_suffix(s_ptr, suffix_ptr);
}

export fn to_upper(s: String): String {
    let s_ptr: *u8 = &s;
    let result_ptr: *u8 = vex_str_to_upper(s_ptr);
    return result_ptr;
}

export fn to_lower(s: String): String {
    let s_ptr: *u8 = &s;
    let result_ptr: *u8 = vex_str_to_lower(s_ptr);
    return result_ptr;
}

export fn trim(s: String): String {
    let s_ptr: *u8 = &s;
    let result_ptr: *u8 = vex_str_trim(s_ptr);
    return result_ptr;
}

export fn replace(s: String, old_str: String, new_str: String): String {
    let s_ptr: *u8 = &s;
    let old_ptr: *u8 = &old_str;
    let new_ptr: *u8 = &new_str;
    let result_ptr: *u8 = vex_str_replace(s_ptr, old_ptr, new_ptr);
    return result_ptr;
}

