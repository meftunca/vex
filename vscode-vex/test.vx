// Vex Language Extension Test File
// Open this file to verify syntax highlighting

// 1. Import statements (ES6-style)
import { HashMap } from "std/collections";
import * as io from "std/io";

// 2. Constants and variables
const MAX_SIZE: i32 = 1000;
let immutable = 42;
let! mutable = 0;  // Mutable with ! suffix

// 3. Struct with export
export struct Point {
    x: f32,
    y: f32,
}

// 4. Implementation block
impl Point {
    export fn new(x: f32, y: f32): Self {
        return Point { x: x, y: y };
    }
    
    export fn distance(&self, other: &Point): f32 {
        let dx = self.x - other.x;
        let dy = self.y - other.y;
        return sqrt(dx * dx + dy * dy);
    }
    
    export fn move(&self!, dx: f32, dy: f32) {
        self.x = self.x + dx;
        self.y = self.y + dy;
    }
}

// 5. Trait definition
export trait Drawable {
    fn draw(&self);
    fn area(&self): f32;
}

// 6. Trait implementation
impl Drawable for Point {
    fn draw(&self) {
        println("Point at ({}, {})", self.x, self.y);
    }
    
    fn area(&self): f32 {
        return 0.0;  // Point has no area
    }
}

// 7. Generic function
export fn swap<T>(a: &T!, b: &T!) {
    let temp = *a;
    *a = *b;
    *b = temp;
}

// 8. Enum
export enum Color {
    Red,
    Green,
    Blue,
    RGB(u8, u8, u8),
}

// 9. Pattern matching
export fn color_name(color: Color): string {
    return match color {
        Color.Red => "red",
        Color.Green => "green",
        Color.Blue => "blue",
        Color.RGB(r, g, b) => "custom",
        _ => "unknown",
    };
}

// 10. Control flow
export fn fibonacci(n: i32): i32 {
    if n <= 1 {
        return n;
    }
    
    let! a = 0;
    let! b = 1;
    
    for i in 2..=n {
        let temp = a + b;
        a = b;
        b = temp;
    }
    
    return b;
}

// 11. Async function
export async fn fetch_data(url: string): Result<string, Error> {
    let response = await http.get(url);
    return Ok(response.body);
}

// 12. Unsafe block
export fn raw_pointer_demo() {
    unsafe {
        let ptr = malloc(100);
        memset(ptr, 0, 100);
        free(ptr);
    }
}

// 13. Attributes
@test
fn test_point() {
    let p = Point.new(3.0, 4.0);
    assert(p.x == 3.0);
}

@inline
fn fast_add(a: i32, b: i32): i32 {
    return a + b;
}

// 14. Macro call
println!("Hello, {}!", "world");

// 15. Main function
fn main(): i32 {
    // References
    let x = 42;
    let ref_x = &x;           // Immutable reference
    
    let! y = 100;
    let ref_y = &y!;          // Mutable reference with !
    
    // Type introspection
    println("Type of x: {}", typeof(x));
    println("Size of Point: {}", sizeof(Point));
    
    // HashMap usage
    let! map = HashMap.new();
    map.insert("key", 42);
    
    // Array operations
    let arr = [1, 2, 3, 4, 5];
    let sum = arr.iter().sum();
    
    return 0;
}

// 16. Comments work correctly
/* 
   Multi-line comment
   with multiple lines
*/

// Single line comment with TODO: Add more features

// 17. String interpolation
let name = "Vex";
let version = "0.9";
println("Welcome to {name} v{version}!");

// 18. Number literals
let hex = 0xFF;
let binary = 0b1010;
let octal = 0o77;
let float = 3.14f32;
let exp = 1.5e10;

// 19. Character literal
let ch = 'A';
let unicode = '\u{1F600}';

// 20. Defer statement
fn cleanup_demo() {
    let file = open("test.txt");
    defer { close(file); };
    
    // File will be closed when function returns
}
