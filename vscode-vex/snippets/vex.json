{
  "Main Function": {
    "prefix": "main",
    "body": ["fn main() : i32 {", "\t$0", "\treturn 0;", "}"],
    "description": "Main function template"
  },
  "Function": {
    "prefix": "fn",
    "body": ["fn ${1:name}(${2:params}) : ${3:i32} {", "\t$0", "}"],
    "description": "Function declaration"
  },
  "Export Function": {
    "prefix": "efn",
    "body": ["export fn ${1:name}(${2:params}) : ${3:i32} {", "\t$0", "}"],
    "description": "Exported function declaration"
  },
  "Struct": {
    "prefix": "struct",
    "body": ["struct ${1:Name} {", "\t${2:field}: ${3:i32},", "}"],
    "description": "Struct declaration"
  },
  "Struct with Trait": {
    "prefix": "structimpl",
    "body": [
      "struct ${1:Name} impl ${2:Trait} {",
      "\t${3:field}: ${4:i32},",
      "\t",
      "\tfn (self: &${1:Name})${5:method}() : ${6:i32} {",
      "\t\t$0",
      "\t}",
      "}"
    ],
    "description": "Struct with inline trait implementation"
  },
  "Export Struct": {
    "prefix": "estruct",
    "body": ["export struct ${1:Name} {", "\t${2:field}: ${3:i32},", "}"],
    "description": "Exported struct declaration"
  },
  "Enum": {
    "prefix": "enum",
    "body": ["enum ${1:Name} {", "\t${2:Variant1},", "\t${3:Variant2},", "}"],
    "description": "Enum declaration"
  },
  "Trait": {
    "prefix": "trait",
    "body": ["trait ${1:Name} {", "\tfn${2:method}() : ${3:i32};", "}"],
    "description": "Trait declaration"
  },
  "Impl Trait": {
    "prefix": "impl",
    "body": [
      "impl ${1:Trait} for ${2:Type} {",
      "\tfn (self: &${2:Type})${3:method}() : ${4:i32} {",
      "\t\t$0",
      "\t}",
      "}"
    ],
    "description": "Separate trait implementation"
  },
  "Golang Method": {
    "prefix": "method",
    "body": [
      "fn (self: &${1:Type}) ${2:method_name}() : ${3:i32} {",
      "\t$0",
      "}"
    ],
    "description": "Golang-style method"
  },
  "Mutable Method": {
    "prefix": "methodmut",
    "body": [
      "fn (self: &${1:Type}!) ${2:method_name}() : ${3:i32} {",
      "\t$0",
      "}"
    ],
    "description": "Golang-style mutable method"
  },
  "Let Immutable": {
    "prefix": "let",
    "body": "let ${1:name} = ${2:value};",
    "description": "Immutable variable"
  },
  "Let Mutable": {
    "prefix": "letm",
    "body": "let! ${1:name} = ${2:value};",
    "description": "Mutable variable (let!)"
  },
  "Const": {
    "prefix": "const",
    "body": "const ${1:NAME}: ${2:i32} = ${3:0};",
    "description": "Constant declaration"
  },
  "If Statement": {
    "prefix": "if",
    "body": ["if ${1:condition} {", "\t$0", "}"],
    "description": "If statement"
  },
  "If-Else": {
    "prefix": "ife",
    "body": ["if ${1:condition} {", "\t$0", "} else {", "\t", "}"],
    "description": "If-else statement"
  },
  "Match": {
    "prefix": "match",
    "body": [
      "match ${1:value} {",
      "\t${2:pattern} => ${3:result},",
      "\t_ => ${4:default},",
      "}"
    ],
    "description": "Match expression"
  },
  "For Loop": {
    "prefix": "for",
    "body": ["for ${1:i} in ${2:0}..${3:10} {", "\t$0", "}"],
    "description": "For loop"
  },
  "While Loop": {
    "prefix": "while",
    "body": ["while ${1:condition} {", "\t$0", "}"],
    "description": "While loop"
  },
  "Import": {
    "prefix": "import",
    "body": "import { ${1:items} } from \"${2:module}\";",
    "description": "Import statement"
  },
  "Import All": {
    "prefix": "importall",
    "body": "import * as ${1:alias} from \"${2:module}\";",
    "description": "Import all as alias"
  },
  "Println": {
    "prefix": "println",
    "body": "println(\"${1:message}\");",
    "description": "Print line"
  },
  "Assert": {
    "prefix": "assert",
    "body": "assert(${1:condition}, \"${2:message}\");",
    "description": "Assert statement"
  },
  "Generic Function": {
    "prefix": "fng",
    "body": [
      "fn ${1:name}<${2:T}>(${3:param}: ${2:T}) : ${4:T} {",
      "\t$0",
      "}"
    ],
    "description": "Generic function"
  },
  "Test Function": {
    "prefix": "test",
    "body": ["@test", "fn test_${1:name}() {", "\t$0", "}"],
    "description": "Test function"
  },
  "Unsafe Block": {
    "prefix": "unsafe",
    "body": ["unsafe {", "\t$0", "}"],
    "description": "Unsafe block"
  },
  "Defer": {
    "prefix": "defer",
    "body": "defer { $0 };",
    "description": "Defer statement"
  },
  "Result Type": {
    "prefix": "result",
    "body": "Result<${1:T}, ${2:Error}>",
    "description": "Result type"
  },
  "Option Type": {
    "prefix": "option",
    "body": "Option<${1:T}>",
    "description": "Option type"
  },
  "Switch Statement": {
    "prefix": "switch",
    "body": [
      "switch ${1:value} {",
      "\tcase ${2:1}:",
      "\t\t${3:// code}",
      "\tdefault:",
      "\t\t${4:// default}",
      "}"
    ],
    "description": "Switch statement"
  },
  "Goroutine": {
    "prefix": "go",
    "body": "go ${1:function_call}();",
    "description": "Spawn goroutine"
  },
  "Async Function": {
    "prefix": "async",
    "body": ["async fn ${1:name}(${2:params}) : ${3:i32} {", "\t$0", "}"],
    "description": "Async function"
  },
  "Channel": {
    "prefix": "channel",
    "body": "let ${1:ch} = channel_new<${2:i32}>();",
    "description": "Create channel"
  },
  "Vec": {
    "prefix": "vec",
    "body": "let ${1:v} = vec_new<${2:i32}>();",
    "description": "Create Vec"
  },
  "Map": {
    "prefix": "map",
    "body": "let ${1:m} = map_new<${2:string}, ${3:i32}>();",
    "description": "Create Map"
  },
  "Set": {
    "prefix": "set",
    "body": "let ${1:s} = set_new<${2:i32}>();",
    "description": "Create Set"
  },
  "Box": {
    "prefix": "box",
    "body": "let ${1:b} = box_new(${2:value});",
    "description": "Create Box"
  },
  "Some": {
    "prefix": "some",
    "body": "Some(${1:value})",
    "description": "Option Some variant"
  },
  "None": {
    "prefix": "none",
    "body": "None",
    "description": "Option None variant"
  },
  "Ok": {
    "prefix": "ok",
    "body": "Ok(${1:value})",
    "description": "Result Ok variant"
  },
  "Err": {
    "prefix": "err",
    "body": "Err(${1:error})",
    "description": "Result Err variant"
  },
  "Typeof": {
    "prefix": "typeof",
    "body": "typeof(${1:value})",
    "description": "Get type name"
  },
  "Logger Debug": {
    "prefix": "logd",
    "body": "logger.debug(\"${1:message}\");",
    "description": "Log debug message"
  },
  "Logger Info": {
    "prefix": "logi",
    "body": "logger.info(\"${1:message}\");",
    "description": "Log info message"
  },
  "Logger Warn": {
    "prefix": "logw",
    "body": "logger.warn(\"${1:message}\");",
    "description": "Log warning message"
  },
  "Logger Error": {
    "prefix": "loge",
    "body": "logger.error(\"${1:message}\");",
    "description": "Log error message"
  },
  "Testing Assert": {
    "prefix": "tassert",
    "body": "testing.assert(${1:condition});",
    "description": "Testing assert"
  },
  "Testing Assert Eq": {
    "prefix": "tasserteq",
    "body": "testing.assert_eq(${1:actual}, ${2:expected});",
    "description": "Testing assert equal"
  }
}
