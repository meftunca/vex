// Test: Filesystem operations (mkdir, rmdir, unlink, rename, stat, readdir)
// Tests all filesystem operations with libc FFI

import { libc } from "std/ffi";

fn test_directory_operations() {
    println("=== Directory Operations Test ===");
    
    // Create directory
    let dir_name = "test_directory\0".as_bytes().as_ptr();
    let result = libc.safe_mkdir(dir_name, libc.S_IRWXU | libc.S_IRWXG | libc.S_IROTH | libc.S_IXOTH);
    
    match result {
        success: i32 => {
            println("✓ Created directory: test_directory");
        },
        err: error => {
            println("✗ Failed to create directory");
            return;
        },
    }
    
    // Remove directory
    let rm_result = libc.safe_rmdir(dir_name);
    match rm_result {
        success: i32 => println("✓ Removed directory: test_directory"),
        err: error => println("✗ Failed to remove directory"),
    }
}

fn test_file_operations() {
    println("\n=== File Operations Test ===");
    
    // Create a test file
    let filename = "test_file.txt\0".as_bytes().as_ptr();
    let fd = unsafe { libc.open(filename, libc.O_CREAT | libc.O_WRONLY | libc.O_TRUNC, 0o644) };
    
    if fd < 0 {
        println("✗ Failed to create file");
        return;
    }
    
    // Write some data
    let data = "Hello, Vex filesystem!\n\0".as_bytes();
    let written = unsafe { libc.write(fd, data.as_ptr(), data.len()) };
    unsafe { libc.close(fd); }
    
    println("✓ Created file: test_file.txt ({} bytes)", written);
    
    // Rename file
    let new_filename = "test_file_renamed.txt\0".as_bytes().as_ptr();
    let rename_result = libc.safe_rename(filename, new_filename);
    
    match rename_result {
        success: i32 => println("✓ Renamed: test_file.txt -> test_file_renamed.txt"),
        err: error => println("✗ Failed to rename file"),
    }
    
    // Delete file
    let unlink_result = libc.safe_unlink(new_filename);
    match unlink_result {
        success: i32 => println("✓ Deleted file: test_file_renamed.txt"),
        err: error => println("✗ Failed to delete file"),
    }
}

fn test_stat_operations() {
    println("\n=== File Stat Test ===");
    
    // Create a file to stat
    let filename = "test_stat.txt\0".as_bytes().as_ptr();
    let fd = unsafe { libc.open(filename, libc.O_CREAT | libc.O_WRONLY | libc.O_TRUNC, 0o644) };
    
    if fd < 0 {
        println("✗ Failed to create file for stat test");
        return;
    }
    
    let data = "Test data for stat\0".as_bytes();
    unsafe { libc.write(fd, data.as_ptr(), data.len()); }
    unsafe { libc.close(fd); }
    
    // Allocate stat buffer
    let stat_size: usize = 144; // sizeof(struct stat) on most platforms
    let stat_buf_result = libc.safe_malloc(stat_size);
    
    match stat_buf_result {
        stat_buf: *mut byte => {
            // Get file status
            let stat_result = libc.safe_stat(filename, stat_buf as *mut libc.stat);
            
            match stat_result {
                success: i32 => {
                    println("✓ Got file status for: test_stat.txt");
                    // TODO: Extract and display stat fields (size, mode, time)
                    // For now, we just verify stat() works
                },
                err: error => {
                    println("✗ Failed to stat file");
                },
            }
            
            libc.safe_free(stat_buf);
        },
        err: error => {
            println("✗ Failed to allocate stat buffer");
        },
    }
    
    // Clean up
    libc.safe_unlink(filename);
}

fn test_directory_listing() {
    println("\n=== Directory Listing Test ===");
    
    // Create test directory with files
    let dir_name = "test_listing\0".as_bytes().as_ptr();
    libc.safe_mkdir(dir_name, libc.S_IRWXU | libc.S_IRWXG | libc.S_IROTH | libc.S_IXOTH);
    
    // Create some test files in directory
    create_test_file("test_listing/file1.txt\0");
    create_test_file("test_listing/file2.txt\0");
    create_test_file("test_listing/file3.txt\0");
    
    println("✓ Created test directory with 3 files");
    
    // Open directory
    let dir_result = libc.safe_opendir(dir_name);
    
    match dir_result {
        dir_handle: *mut libc.DIR => {
            println("✓ Opened directory: test_listing");
            println("\nDirectory contents:");
            
            // Read directory entries
            let mut count = 0;
            loop {
                let entry = libc.safe_readdir(dir_handle);
                
                if entry as usize == 0 {
                    break;
                }
                
                count = count + 1;
                println("  - Entry #{}", count);
                // TODO: Extract filename from dirent struct
                // For now, we just count entries
            }
            
            println("\nTotal entries found: {}", count);
            
            // Close directory
            let close_result = libc.safe_closedir(dir_handle);
            match close_result {
                success: i32 => println("✓ Closed directory"),
                err: error => println("✗ Failed to close directory"),
            }
        },
        err: error => {
            println("✗ Failed to open directory");
        },
    }
    
    // Clean up
    cleanup_test_directory();
}

fn create_test_file(path: *byte) {
    let fd = unsafe { libc.open(path, libc.O_CREAT | libc.O_WRONLY | libc.O_TRUNC, 0o644) };
    if fd >= 0 {
        let data = "test\0".as_bytes();
        unsafe { libc.write(fd, data.as_ptr(), data.len()); }
        unsafe { libc.close(fd); }
    }
}

fn cleanup_test_directory() {
    // Delete files
    libc.safe_unlink("test_listing/file1.txt\0".as_bytes().as_ptr());
    libc.safe_unlink("test_listing/file2.txt\0".as_bytes().as_ptr());
    libc.safe_unlink("test_listing/file3.txt\0".as_bytes().as_ptr());
    
    // Remove directory
    libc.safe_rmdir("test_listing\0".as_bytes().as_ptr());
    
    println("✓ Cleaned up test directory");
}

fn main() -> i32 {
    println("Vex Filesystem Operations Test");
    println("================================\n");
    
    test_directory_operations();
    test_file_operations();
    test_stat_operations();
    test_directory_listing();
    
    println("\n=== All Tests Complete ===");
    return 0;
}
