// Multiple contract Implementation Test
// struct Foo impl contract1, contract2, contract3 { ... }

// Define multiple contracts
contract Display {
    show();
}

contract Serializable {
    serialize() : i32;
}

contract Comparable {
    compare(other: &Self) : i32;
}

// Struct implementing multiple contracts at once
struct Person impl Display, Serializable, Comparable {
    name: string,
    age: i32,
    
    // Display implementation
    fn (self: &Person!) show() {
        // Show person info
    }
    
    // Serializable implementation
    fn (self: &Person!) serialize() : i32 {
        return 1;
    }
    
    // Comparable implementation
    fn (self: &Person!) compare(other: &Person) : i32 {
        let self_age = self.age;
        return self_age;
    }
    
    // Struct-specific method
    fn (self: &Person!) birthday() {
        // Increment age
    }
}

fn main() {
    let! p = Person { name: "Alice", age: 30 };
    
    // Call methods from different contracts
    p.show();           // Display contract
    let s = p.serialize();    // Serializable contract
    // let c = p.compare(&p);    // Comparable contract - TODO: reference expression in codegen
    
    // Call struct-specific method
    p.birthday();
}
