// Test Iterator adapter methods: map, filter, take, skip
// Demonstrates functional-style iteration



contract Iterator {
    type Item;
    next()!: Option<i32>;
}

// Simple range iterator for testing
struct Range impl Iterator {
    current: i32,
    end: i32,
    
    fn next()!: Option<i32> {
        if self.current < self.end {
            let val = self.current;
            self.current = self.current + 1;
            return Some(val);
        }
        return None;
    }
}

fn main(): i32 {
    // Test Range iterator
    let! range = Range { current: 0, end: 5 };
    
    let out1 = range.next();
    let check1 = match out1 {
        Some(0) => {
            println("✅ Range iterator works!");
            0
        }
        _ => 1,
    };
    
    if check1 != 0 {
        return 1;
    }
    
    let out2 = range.next();
    let check2 = match out2 {
        Some(1) => {
            println("✅ Range next() increments!");
            0
        }
        _ => 1,
    };
    
    return check2;
}
