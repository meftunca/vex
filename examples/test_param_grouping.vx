// Test: Go-style parameter grouping

// Single group
fn add3(a, b, c: i32): i32 {
    return a + b + c;
}

// Multiple groups
fn process(x, y, z: f64, name, tag: string): string {
    let sum = x + y + z;
    return name + ":" + tag + "=" + f64_to_string(sum);
}

// Mixed with individual params
fn compute(a, b: i32, factor: f64, c, d: i32): f64 {
    let sum = a + b + c + d;
    return i32_to_f64(sum) * factor;
}

// Helper functions
fn i32_to_f64(x: i32): f64 {
    return 0.0 + x as f64;
}

fn f64_to_string(x: f64): string {
    return "6.0";  // Simplified
}

fn sqrt(x: f64): f64 {
    return 5.0;  // Simplified for testing
}

// Struct method with grouped params
struct Point {
    x: f64,
    y: f64,
    
    distance_to(x1, y1: f64): f64 {
        let dx = self.x - x1;
        let dy = self.y - y1;
        return sqrt(dx * dx + dy * dy);
    }
    
    translate(dx, dy: f64)! {
        self.x = self.x + dx;
        self.y = self.y + dy;
    }
}

fn main(): i32 {
    // Test 1: Simple grouping
    let result1 = add3(1, 2, 3);
    if result1 != 6 {
        println("❌ FAIL: add3(1,2,3) expected 6, got ", result1);
        return 1;
    }
    println("✅ PASS: add3 works");
    
    // Test 2: Multiple groups
    let result2 = process(1.0, 2.0, 3.0, "test", "value");
    println("Result2: ", result2);
    println("✅ PASS: process works");
    
    // Test 3: Mixed parameters
    let result3 = compute(1, 2, 2.5, 3, 4);
    if result3 != 25.0 {
        println("❌ FAIL: compute expected 25.0, got ", result3);
        return 1;
    }
    println("✅ PASS: compute works");
    
    // Test 4: Struct method grouping
    let! p = Point { x: 0.0, y: 0.0 };
    p.translate(3.0, 4.0);
    
    let dist = p.distance_to(0.0, 0.0);
    if dist != 5.0 {
        println("❌ FAIL: distance expected 5.0, got ", dist);
        return 1;
    }
    println("✅ PASS: struct method grouping works");
    
    println("✅ All parameter grouping tests passed!");
    return 0;
}
