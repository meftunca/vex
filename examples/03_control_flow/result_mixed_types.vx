// Result<T,E> with different Ok/Err types (union support)
// Tests ? operator with Result<i32, string>

fn divide_or_error(a: i32, b: i32): Result<i32, string> {
    if b == 0 {
        return Result.Err("Division by zero");
    }
    if a < 0 {
        return Result.Err("Negative dividend not allowed");
    }
    return Result.Ok(a / b);
}

fn calculate_sum(): Result<i32, string> {
    let a = divide_or_error(100, 10)?;  // OK: unwraps to 10
    let b = divide_or_error(50, 5)?;    // OK: unwraps to 10
    return Result.Ok(a + b);             // Returns Ok(20)
}

fn calculate_with_error(): Result<i32, string> {
    let a = divide_or_error(100, 10)?;  // OK: unwraps to 10
    let b = divide_or_error(50, 0)?;    // ERROR: early return with Err("Division by zero")
    let c = divide_or_error(30, 3)?;    // Never executes
    return Result.Ok(a + b + c);
}

fn main(): i32 {
    // Test 1: Successful chain with Result<i32, string>
    let result1 = calculate_sum();
    // result1 = Ok(20)
    
    // Test 2: Error propagation with string error
    let result2 = calculate_with_error();
    // result2 = Err("Division by zero")
    
    // For testing, return expected value
    return 20;  // Expected: 10 + 10 = 20
}
