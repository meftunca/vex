// Test: POSIX threads mutex and condition variables
// WARNING: These are BLOCKING operations, not for async tasks!

import { libc } from "std/ffi";

extern "C" {
    fn printf(fmt: *byte, ...) -> i32;
}

fn test_mutex_basic() {
    printf("\n=== Basic Mutex Test ===\n\0".as_bytes().as_ptr());
    
    // Allocate mutex (64 bytes for safety)
    let mutex = unsafe { libc.malloc(64) };
    if mutex as usize == 0 {
        printf("✗ Failed to allocate mutex\n\0".as_bytes().as_ptr());
        return;
    }
    
    // Initialize mutex
    let init_result = unsafe { libc.pthread_mutex_init(mutex as *mut libc.pthread_mutex_t,
                                                        0 as *libc.pthread_mutexattr_t) };
    
    if init_result != 0 {
        printf("✗ Failed to initialize mutex\n\0".as_bytes().as_ptr());
        unsafe { libc.free(mutex); }
        return;
    }
    
    printf("✓ Mutex initialized\n\0".as_bytes().as_ptr());
    
    // Lock mutex
    let lock_result = unsafe { libc.pthread_mutex_lock(mutex as *mut libc.pthread_mutex_t) };
    
    if lock_result == 0 {
        printf("✓ Mutex locked\n\0".as_bytes().as_ptr());
    } else {
        printf("✗ Failed to lock mutex\n\0".as_bytes().as_ptr());
    }
    
    // Try to lock again (should fail or block if not recursive)
    let trylock_result = unsafe { libc.pthread_mutex_trylock(mutex as *mut libc.pthread_mutex_t) };
    
    if trylock_result == libc.EBUSY {
        printf("✓ Trylock correctly failed (mutex already locked)\n\0".as_bytes().as_ptr());
    } else if trylock_result == 0 {
        printf("⚠ Trylock succeeded (recursive mutex?)\n\0".as_bytes().as_ptr());
        unsafe { libc.pthread_mutex_unlock(mutex as *mut libc.pthread_mutex_t); }
    } else {
        printf("✗ Trylock failed with unexpected error\n\0".as_bytes().as_ptr());
    }
    
    // Unlock mutex
    let unlock_result = unsafe { libc.pthread_mutex_unlock(mutex as *mut libc.pthread_mutex_t) };
    
    if unlock_result == 0 {
        printf("✓ Mutex unlocked\n\0".as_bytes().as_ptr());
    } else {
        printf("✗ Failed to unlock mutex\n\0".as_bytes().as_ptr());
    }
    
    // Destroy mutex
    let destroy_result = unsafe { libc.pthread_mutex_destroy(mutex as *mut libc.pthread_mutex_t) };
    
    if destroy_result == 0 {
        printf("✓ Mutex destroyed\n\0".as_bytes().as_ptr());
    } else {
        printf("✗ Failed to destroy mutex\n\0".as_bytes().as_ptr());
    }
    
    unsafe { libc.free(mutex); }
}

fn test_condition_variable() {
    printf("\n=== Condition Variable Test ===\n\0".as_bytes().as_ptr());
    
    // Allocate mutex and condition variable
    let mutex = unsafe { libc.malloc(64) };
    let cond = unsafe { libc.malloc(48) };
    
    if mutex as usize == 0 || cond as usize == 0 {
        printf("✗ Failed to allocate mutex/cond\n\0".as_bytes().as_ptr());
        return;
    }
    
    // Initialize
    let mutex_init = unsafe { libc.pthread_mutex_init(mutex as *mut libc.pthread_mutex_t,
                                                       0 as *libc.pthread_mutexattr_t) };
    let cond_init = unsafe { libc.pthread_cond_init(cond as *mut libc.pthread_cond_t,
                                                     0 as *libc.pthread_condattr_t) };
    
    if mutex_init != 0 || cond_init != 0 {
        printf("✗ Failed to initialize mutex/cond\n\0".as_bytes().as_ptr());
        unsafe { libc.free(mutex); }
        unsafe { libc.free(cond); }
        return;
    }
    
    printf("✓ Mutex and CondVar initialized\n\0".as_bytes().as_ptr());
    
    // Lock mutex
    unsafe { libc.pthread_mutex_lock(mutex as *mut libc.pthread_mutex_t); }
    
    // Signal (should be no-op since no one is waiting)
    let signal_result = unsafe { libc.pthread_cond_signal(cond as *mut libc.pthread_cond_t) };
    
    if signal_result == 0 {
        printf("✓ Condition variable signaled (no waiters)\n\0".as_bytes().as_ptr());
    } else {
        printf("✗ Failed to signal condition variable\n\0".as_bytes().as_ptr());
    }
    
    // Broadcast (should also be no-op)
    let broadcast_result = unsafe { libc.pthread_cond_broadcast(cond as *mut libc.pthread_cond_t) };
    
    if broadcast_result == 0 {
        printf("✓ Condition variable broadcast (no waiters)\n\0".as_bytes().as_ptr());
    } else {
        printf("✗ Failed to broadcast condition variable\n\0".as_bytes().as_ptr());
    }
    
    // Unlock mutex
    unsafe { libc.pthread_mutex_unlock(mutex as *mut libc.pthread_mutex_t); }
    
    // Note: We can't test pthread_cond_wait without multiple threads
    // That would require pthread_create which is more complex
    printf("⚠ pthread_cond_wait not tested (requires multiple threads)\n\0".as_bytes().as_ptr());
    
    // Clean up
    unsafe { libc.pthread_cond_destroy(cond as *mut libc.pthread_cond_t); }
    unsafe { libc.pthread_mutex_destroy(mutex as *mut libc.pthread_mutex_t); }
    unsafe { libc.free(cond); }
    unsafe { libc.free(mutex); }
    
    printf("✓ Cleanup complete\n\0".as_bytes().as_ptr());
}

fn test_safe_wrappers() {
    printf("\n=== Safe Wrapper Test ===\n\0".as_bytes().as_ptr());
    
    let mutex = unsafe { libc.malloc(64) };
    if mutex as usize == 0 {
        printf("✗ Failed to allocate mutex\n\0".as_bytes().as_ptr());
        return;
    }
    
    // Test safe_pthread_mutex_init
    let init_result = libc.safe_pthread_mutex_init(mutex as *mut libc.pthread_mutex_t);
    
    match init_result {
        success: i32 => {
            printf("✓ safe_pthread_mutex_init succeeded\n\0".as_bytes().as_ptr());
        },
        err: error => {
            printf("✗ safe_pthread_mutex_init failed\n\0".as_bytes().as_ptr());
            unsafe { libc.free(mutex); }
            return;
        },
    }
    
    // Test safe_pthread_mutex_lock
    let lock_result = libc.safe_pthread_mutex_lock(mutex as *mut libc.pthread_mutex_t);
    
    match lock_result {
        success: i32 => {
            printf("✓ safe_pthread_mutex_lock succeeded\n\0".as_bytes().as_ptr());
        },
        err: error => {
            printf("✗ safe_pthread_mutex_lock failed\n\0".as_bytes().as_ptr());
        },
    }
    
    // Test safe_pthread_mutex_trylock (should fail)
    let trylock_result = libc.safe_pthread_mutex_trylock(mutex as *mut libc.pthread_mutex_t);
    
    match trylock_result {
        locked: bool => {
            if !locked {
                printf("✓ safe_pthread_mutex_trylock correctly returned false\n\0".as_bytes().as_ptr());
            } else {
                printf("⚠ safe_pthread_mutex_trylock returned true (recursive?)\n\0".as_bytes().as_ptr());
                // Unlock the extra lock
                libc.safe_pthread_mutex_unlock(mutex as *mut libc.pthread_mutex_t);
            }
        },
        err: error => {
            printf("✗ safe_pthread_mutex_trylock returned error\n\0".as_bytes().as_ptr());
        },
    }
    
    // Test safe_pthread_mutex_unlock
    let unlock_result = libc.safe_pthread_mutex_unlock(mutex as *mut libc.pthread_mutex_t);
    
    match unlock_result {
        success: i32 => {
            printf("✓ safe_pthread_mutex_unlock succeeded\n\0".as_bytes().as_ptr());
        },
        err: error => {
            printf("✗ safe_pthread_mutex_unlock failed\n\0".as_bytes().as_ptr());
        },
    }
    
    // Test safe_pthread_mutex_destroy
    let destroy_result = libc.safe_pthread_mutex_destroy(mutex as *mut libc.pthread_mutex_t);
    
    match destroy_result {
        success: i32 => {
            printf("✓ safe_pthread_mutex_destroy succeeded\n\0".as_bytes().as_ptr());
        },
        err: error => {
            printf("✗ safe_pthread_mutex_destroy failed\n\0".as_bytes().as_ptr());
        },
    }
    
    unsafe { libc.free(mutex); }
}

fn main() -> i32 {
    printf("=== POSIX Threads Test Suite ===\n\0".as_bytes().as_ptr());
    printf("WARNING: These are BLOCKING operations!\n\0".as_bytes().as_ptr());
    printf("Do NOT use in async Vex tasks.\n\0".as_bytes().as_ptr());
    
    test_mutex_basic();
    test_condition_variable();
    test_safe_wrappers();
    
    printf("\n=== All Tests Complete ===\n\0".as_bytes().as_ptr());
    return 0;
}
