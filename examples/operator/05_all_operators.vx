// Comprehensive operator overloading test

// Arithmetic operators
contract Add {
    op+(other: Self): Self;
}

contract Sub {
    op-(other: Self): Self;
}

contract Mul {
    op*(other: Self): Self;
}

contract Div {
    op/(other: Self): Self;
}

contract Rem {
    op%(other: Self): Self;
}

// Comparison operators
contract Eq {
    op==(other: Self): bool;
    op!=(other: Self): bool;
}

contract Ord {
    op<(other: Self): bool;
    op<=(other: Self): bool;
    op>(other: Self): bool;
    op>=(other: Self): bool;
}

// Bitwise operators
contract BitAnd {
    op&(other: Self): Self;
}

contract BitOr {
    op|(other: Self): Self;
}

contract BitXor {
    op^(other: Self): Self;
}

contract Shl {
    op<<(amount: i32): Self;
}

contract Shr {
    op>>(amount: i32): Self;
}

// Unary operators
contract Neg {
    op-(): Self;
}

contract Not {
    op!(): bool;
}

struct Point impl Add, Sub, Mul, Eq {
    x: i32,
    y: i32,

    fn op+(other: Point): Point {
        return Point { x: self.x + other.x, y: self.y + other.y };
    }

    fn op-(other: Point): Point {
        return Point { x: self.x - other.x, y: self.y - other.y };
    }

    fn op*(other: Point): Point {
        return Point { x: self.x * other.x, y: self.y * other.y };
    }

    fn op==(other: Point): bool {
        return self.x == other.x && self.y == other.y;
    }
    
    fn op!=(other: Point): bool {
        return !(self == other);
    }
}

fn test_arithmetic(): i32 {
    let p1 = Point { x: 10, y: 20 };
    let p2 = Point { x: 5, y: 3 };
    
    let p_add = p1 + p2;
    println("Add: ({}, {})", p_add.x, p_add.y);
    
    let p_sub = p1 - p2;
    println("Sub: ({}, {})", p_sub.x, p_sub.y);
    
    let p_mul = p1 * p2;
    println("Mul: ({}, {})", p_mul.x, p_mul.y);
    
    return 0;
}

fn test_comparison(): i32 {
    let p1 = Point { x: 10, y: 20 };
    let p2 = Point { x: 10, y: 20 };
    let p3 = Point { x: 5, y: 3 };
    
    if p1 == p2 {
        println("✅ p1 == p2");
    }
    
    if !(p1 == p3) {
        println("✅ p1 != p3");
    }
    
    return 0;
}

fn test_builtin_ops(): i32 {
    // String concat
    let s1 = "Hello";
    let s2 = " World";
    let s3 = s1 + s2;
    println("String: {}", s3);
    
    // Vec concat
    let v1: Vec<i32> = [1, 2, 3];
    let v2: Vec<i32> = [4, 5, 6];
    let v3 = v1 + v2;
    println("Vec concat done");
    
    return 0;
}

fn test_numeric_ops(): i32 {
    let a = 42;
    let b = 10;
    
    println("Add: {}", a + b);
    println("Sub: {}", a - b);
    println("Mul: {}", a * b);
    println("Div: {}", a / b);
    println("Rem: {}", a % b);
    
    println("Eq: {}", a == b);
    println("Ne: {}", a != b);
    println("Lt: {}", a < b);
    println("Gt: {}", a > b);
    println("Le: {}", a <= b);
    println("Ge: {}", a >= b);
    
    println("BitAnd: {}", a & b);
    println("BitOr: {}", a | b);
    println("BitXor: {}", a ^ b);
    println("Shl: {}", a << 2);
    println("Shr: {}", a >> 2);
    
    println("Neg: {}", -a);
    println("Not: {}", !false);
    
    return 0;
}

fn main(): i32 {
    println("=== Testing Arithmetic Operators ===");
    test_arithmetic();
    
    println("=== Testing Comparison Operators ===");
    test_comparison();
    
    println("=== Testing Builtin Operators ===");
    test_builtin_ops();
    
    println("=== Testing Numeric Operators ===");
    test_numeric_ops();
    
    println("✅ ALL OPERATOR TESTS PASSED");
    return 0;
}