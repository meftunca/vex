// Test 3: Default type parameters - Self reference
// Scenario: Default to Self, use both default and explicit versions

contract Add<Rhs = Self> {
    op+(other: Rhs): Self;
}

contract Mul<Rhs = Self> {
    op*(other: Rhs): Self;
}

struct Vector impl Add, Add<i32>, Mul {
    x: f64,
    y: f64,

    // Add<Self> - default
    fn (self: &Vector!) op+(other: Vector): Vector {
        return Vector { 
            x: self.x + other.x, 
            y: self.y + other.y 
        };
    }

    // Add<i32> - explicit
    fn (self: &Vector!) op+(other: i32): Vector {
        return Vector { 
            x: self.x + other as f64, 
            y: self.y + other as f64 
        };
    }

    // Mul<Self> - default
    fn (self: &Vector!) op*(other: Vector): Vector {
        return Vector { 
            x: self.x * other.x, 
            y: self.y * other.y 
        };
    }
}

fn main(): i32 {
    let v1 = Vector { x: 2.0, y: 3.0 };
    let v2 = Vector { x: 4.0, y: 5.0 };
    
    // Test Add<Self> (default)
    let v3 = v1 + v2;  // (2+4, 3+5) = (6, 8)
    if v3.x as i32 != 6 {
        return 1;
    }
    
    // Test Add<i32> (explicit)
    let v4 = v1 + 10;  // (2+10, 3+10) = (12, 13)
    if v4.x as i32 != 12 {
        return 2;
    }
    
    // Test Mul<Self> (default)
    let v5 = v1 * v2;  // (2*4, 3*5) = (8, 15)
    if v5.x as i32 != 8 {
        return 3;
    }
    
    return 0;  // Success
}
