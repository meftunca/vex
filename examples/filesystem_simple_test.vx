// Simple filesystem test - Basic operations
// Tests: mkdir, file create, rename, unlink, rmdir

import { libc } from "std/ffi";

extern "C" {
    fn printf(fmt: *byte, ...) -> i32;
}

fn main() -> i32 {
    printf("=== Vex Filesystem Test ===\n\0".as_bytes().as_ptr());
    
    // 1. Create directory (mode 0755 = rwxr-xr-x)
    printf("\n1. Creating directory 'vex_test'...\n\0".as_bytes().as_ptr());
    let dir_name = "vex_test\0".as_bytes().as_ptr();
    let mkdir_result = unsafe { libc.mkdir(dir_name, 0o755) };
    
    if mkdir_result == 0 {
        printf("   ✓ Directory created\n\0".as_bytes().as_ptr());
    } else {
        printf("   ✗ Failed (may already exist)\n\0".as_bytes().as_ptr());
    }
    
    // 2. Create a file inside directory
    printf("\n2. Creating file 'vex_test/hello.txt'...\n\0".as_bytes().as_ptr());
    let filename = "vex_test/hello.txt\0".as_bytes().as_ptr();
    let fd = unsafe { libc.open(filename, libc.O_CREAT | libc.O_WRONLY | libc.O_TRUNC, 0o644) };
    
    if fd >= 0 {
        let content = "Hello from Vex!\n\0".as_bytes();
        let written = unsafe { libc.write(fd, content.as_ptr(), content.len() - 1) };
        unsafe { libc.close(fd); }
        printf("   ✓ File created (%d bytes written)\n\0".as_bytes().as_ptr(), written);
    } else {
        printf("   ✗ Failed to create file\n\0".as_bytes().as_ptr());
        return 1;
    }
    
    // 3. Rename file
    printf("\n3. Renaming file to 'vex_test/renamed.txt'...\n\0".as_bytes().as_ptr());
    let new_filename = "vex_test/renamed.txt\0".as_bytes().as_ptr();
    let rename_result = unsafe { libc.rename(filename, new_filename) };
    
    if rename_result == 0 {
        printf("   ✓ File renamed\n\0".as_bytes().as_ptr());
    } else {
        printf("   ✗ Failed to rename\n\0".as_bytes().as_ptr());
    }
    
    // 4. Check file with stat
    printf("\n4. Getting file info with stat()...\n\0".as_bytes().as_ptr());
    let stat_buf = unsafe { libc.malloc(144) }; // sizeof(struct stat)
    
    if stat_buf as usize != 0 {
        let stat_result = unsafe { libc.stat(new_filename, stat_buf as *mut libc.stat) };
        
        if stat_result == 0 {
            // Read st_size field (offset varies by platform, but typically at byte 48)
            let size_ptr = (stat_buf as usize + 48) as *i64;
            let size = unsafe { *size_ptr };
            printf("   ✓ File stat retrieved\n\0".as_bytes().as_ptr());
            printf("   - Size: %lld bytes\n\0".as_bytes().as_ptr(), size);
        } else {
            printf("   ✗ Failed to stat file\n\0".as_bytes().as_ptr());
        }
        
        unsafe { libc.free(stat_buf); }
    }
    
    // 5. List directory contents
    printf("\n5. Listing directory contents...\n\0".as_bytes().as_ptr());
    let dir_handle = unsafe { libc.opendir(dir_name) };
    
    if dir_handle as usize != 0 {
        printf("   ✓ Directory opened\n\0".as_bytes().as_ptr());
        printf("   Contents:\n\0".as_bytes().as_ptr());
        
        loop {
            let entry = unsafe { libc.readdir(dir_handle) };
            
            if entry as usize == 0 {
                break;
            }
            
            // dirent struct: d_name is at offset 19 on Linux, 21 on macOS
            // We'll use offset 19 for now (works on most Linux systems)
            let name_offset: usize = 19;
            let name_ptr = (entry as usize + name_offset) as *byte;
            
            printf("     - %s\n\0".as_bytes().as_ptr(), name_ptr);
        }
        
        unsafe { libc.closedir(dir_handle); }
        printf("   ✓ Directory closed\n\0".as_bytes().as_ptr());
    } else {
        printf("   ✗ Failed to open directory\n\0".as_bytes().as_ptr());
    }
    
    // 6. Delete file
    printf("\n6. Deleting file...\n\0".as_bytes().as_ptr());
    let unlink_result = unsafe { libc.unlink(new_filename) };
    
    if unlink_result == 0 {
        printf("   ✓ File deleted\n\0".as_bytes().as_ptr());
    } else {
        printf("   ✗ Failed to delete file\n\0".as_bytes().as_ptr());
    }
    
    // 7. Remove directory
    printf("\n7. Removing directory...\n\0".as_bytes().as_ptr());
    let rmdir_result = unsafe { libc.rmdir(dir_name) };
    
    if rmdir_result == 0 {
        printf("   ✓ Directory removed\n\0".as_bytes().as_ptr());
    } else {
        printf("   ✗ Failed to remove directory\n\0".as_bytes().as_ptr());
    }
    
    printf("\n=== Test Complete ===\n\0".as_bytes().as_ptr());
    return 0;
}
