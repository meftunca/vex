// Compression Library Benchmark
// Compare zlib, zstd, and lz4 performance

import { ffi } from "std";

fn benchmark_compression(name: string, data: [byte], 
                        compress_fn: fn([byte]) -> ([byte] | error),
                        decompress_fn: fn([byte]) -> ([byte] | error)) {
    // Compression
    let start = time.monotonic_nanos();
    let compressed = compress_fn(data)?;
    let compress_time = time.monotonic_nanos() - start;
    
    let ratio = (data.len() as f64) / (compressed.len() as f64);
    
    // Decompression
    let start2 = time.monotonic_nanos();
    let decompressed = decompress_fn(compressed)?;
    let decompress_time = time.monotonic_nanos() - start2;
    
    // Verify
    if decompressed.len() != data.len() {
        println(f"ERROR: {name} size mismatch!");
        return;
    }
    
    println(f"{name}:");
    println(f"  Original: {data.len()} bytes");
    println(f"  Compressed: {compressed.len()} bytes");
    println(f"  Ratio: {ratio:.2f}x");
    println(f"  Compress time: {compress_time / 1_000_000}ms");
    println(f"  Decompress time: {decompress_time / 1_000_000}ms");
    println(f"  Throughput: {(data.len() * 1_000_000_000) / compress_time / 1024 / 1024}MB/s");
    println("");
}

fn main() : i32 {
    println("=== Compression Library Benchmark ===\n");
    
    // Generate test data (repetitive for better compression)
    let size = 1024 * 1024; // 1MB
    let mut data = make([byte], size);
    
    for i in 0..size {
        data[i] = (i % 256) as byte;
    }
    
    // Test zlib
    benchmark_compression(
        "zlib (level 6)",
        data,
        fn(d) { ffi.zlib.compress_data(d, 6) },
        fn(c) { ffi.zlib.decompress_data(c, size) }
    )?;
    
    // Test zstd - default
    benchmark_compression(
        "zstd (level 3)",
        data,
        fn(d) { ffi.zstd.compress(d, ffi.zstd.ZSTD_DEFAULT_CLEVEL) },
        fn(c) { ffi.zstd.decompress(c) }
    )?;
    
    // Test zstd - fast
    benchmark_compression(
        "zstd (fast)",
        data,
        fn(d) { ffi.zstd.compress_fast(d) },
        fn(c) { ffi.zstd.decompress(c) }
    )?;
    
    // Test zstd - best
    benchmark_compression(
        "zstd (best)",
        data,
        fn(d) { ffi.zstd.compress_best(d) },
        fn(c) { ffi.zstd.decompress(c) }
    )?;
    
    // Test lz4 - default
    benchmark_compression(
        "lz4 (default)",
        data,
        fn(d) { ffi.lz4.compress(d) },
        fn(c) { ffi.lz4.decompress(c, size) }
    )?;
    
    // Test lz4 - ultra fast
    benchmark_compression(
        "lz4 (ultra fast)",
        data,
        fn(d) { ffi.lz4.compress_ultra_fast(d) },
        fn(c) { ffi.lz4.decompress(c, size) }
    )?;
    
    // Test lz4 - HC
    benchmark_compression(
        "lz4 HC (level 9)",
        data,
        fn(d) { ffi.lz4.compress_hc(d, ffi.lz4.LZ4HC_CLEVEL_DEFAULT) },
        fn(c) { ffi.lz4.decompress(c, size) }
    )?;
    
    println("=== Summary ===");
    println("Best speed: lz4 ultra fast");
    println("Best compression: zstd best");
    println("Best balance: zstd default");
    
    return 0;
}
