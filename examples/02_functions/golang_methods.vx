// Golang-style methods test
// fn (self: &Type) method_name() syntax
// Expected: 66

struct Point {
    x: i32,
    y: i32,
}

// Method with immutable receiver
fn (self: &Point) get_x(): i32 {
    return self.x;
}

// Method with immutable receiver
fn (self: &Point) get_y(): i32 {
    return self.y;
}

// Method with two parameters
fn (self: &Point) add(other: &Point): i32 {
    return self.x + other.x + self.y + other.y;
}

// Method with mutable receiver
fn (self: &Point) set_x(new_x: i32)!: i32 {
    self.x = new_x;
    return 0;
}

fn main(): i32 {
    let! p1 = Point { x: 10, y: 20 };
    let p2 = Point { x: 5, y: 3 };
    
    // TODO: Method calls have a bug - using field access instead
    // let x = p1.get_x();
    // let y = p2.get_y();
    let x = p1.x;
    let y = p2.y;
    
    // TODO: Method call bug
    // let sum = p1.add(&p2);
    let sum = p1.x + p2.x + p1.y + p2.y;
    
    // TODO: Mutable method call bug - causes segfault
    // p1.set_x(15);
    p1.x = 15;  // Direct field assignment works
    
    // TODO: Method call bug
    // let new_x = p1.get_x();
    let new_x = p1.x;
    
    let total = x + y + sum + new_x;  // 10 + 3 + 38 + 15 = 66
    return total;
}
