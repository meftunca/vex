// Test: POSIX regex matching
// Tests regcomp, regexec, pattern matching

import { libc } from "std/ffi";

extern "C" {
    fn printf(fmt: *byte, ...) -> i32;
}

fn test_basic_match() {
    printf("\n=== Basic Regex Match Test ===\n\0".as_bytes().as_ptr());
    
    // Allocate regex_t
    let regex = unsafe { libc.malloc(64) };
    if regex as usize == 0 {
        printf("Failed to allocate regex\n\0".as_bytes().as_ptr());
        return;
    }
    
    // Compile pattern: match "hello" (case insensitive)
    let pattern = "hello\0".as_bytes().as_ptr();
    let flags = libc.REG_EXTENDED | libc.REG_ICASE;
    
    let compile_result = unsafe { libc.regcomp(regex as *mut libc.regex_t, pattern, flags) };
    
    if compile_result != 0 {
        printf("✗ Failed to compile regex\n\0".as_bytes().as_ptr());
        unsafe { libc.free(regex); }
        return;
    }
    
    printf("✓ Regex compiled successfully\n\0".as_bytes().as_ptr());
    
    // Test strings
    let test1 = "Hello World\0".as_bytes().as_ptr();
    let test2 = "HELLO there\0".as_bytes().as_ptr();
    let test3 = "goodbye\0".as_bytes().as_ptr();
    
    // Test 1: Should match
    let result1 = unsafe { libc.regexec(regex as *libc.regex_t, test1, 0, 
                                        0 as *mut libc.regmatch_t, 0) };
    if result1 == 0 {
        printf("✓ Test 1: 'Hello World' matched\n\0".as_bytes().as_ptr());
    } else {
        printf("✗ Test 1: 'Hello World' did not match\n\0".as_bytes().as_ptr());
    }
    
    // Test 2: Should match (case insensitive)
    let result2 = unsafe { libc.regexec(regex as *libc.regex_t, test2, 0,
                                        0 as *mut libc.regmatch_t, 0) };
    if result2 == 0 {
        printf("✓ Test 2: 'HELLO there' matched\n\0".as_bytes().as_ptr());
    } else {
        printf("✗ Test 2: 'HELLO there' did not match\n\0".as_bytes().as_ptr());
    }
    
    // Test 3: Should NOT match
    let result3 = unsafe { libc.regexec(regex as *libc.regex_t, test3, 0,
                                        0 as *mut libc.regmatch_t, 0) };
    if result3 == libc.REG_NOMATCH {
        printf("✓ Test 3: 'goodbye' correctly did not match\n\0".as_bytes().as_ptr());
    } else {
        printf("✗ Test 3: 'goodbye' unexpectedly matched\n\0".as_bytes().as_ptr());
    }
    
    // Clean up
    unsafe { libc.regfree(regex as *mut libc.regex_t); }
    unsafe { libc.free(regex); }
}

fn test_capture_groups() {
    printf("\n=== Regex Capture Groups Test ===\n\0".as_bytes().as_ptr());
    
    let regex = unsafe { libc.malloc(64) };
    if regex as usize == 0 {
        printf("Failed to allocate regex\n\0".as_bytes().as_ptr());
        return;
    }
    
    // Pattern to match email: "(.+)@(.+)" 
    let pattern = "([a-zA-Z0-9]+)@([a-zA-Z0-9]+)\\.[a-z]+\0".as_bytes().as_ptr();
    let flags = libc.REG_EXTENDED;
    
    let compile_result = unsafe { libc.regcomp(regex as *mut libc.regex_t, pattern, flags) };
    
    if compile_result != 0 {
        printf("✗ Failed to compile email regex\n\0".as_bytes().as_ptr());
        unsafe { libc.free(regex); }
        return;
    }
    
    printf("✓ Email regex compiled\n\0".as_bytes().as_ptr());
    
    // Allocate matches array (3 groups: full match, username, domain)
    let matches = unsafe { libc.malloc(16 * 3) }; // 3 * sizeof(regmatch_t)
    
    let test_email = "user@example.com\0".as_bytes().as_ptr();
    
    let result = unsafe { libc.regexec(regex as *libc.regex_t, test_email, 3,
                                       matches as *mut libc.regmatch_t, 0) };
    
    if result == 0 {
        printf("✓ Email matched\n\0".as_bytes().as_ptr());
        
        // Extract match positions
        // regmatch_t: { rm_so: i64, rm_eo: i64 }
        let match0_start_ptr = matches as *i64;
        let match0_end_ptr = (matches as usize + 8) as *i64;
        
        let match0_start = unsafe { *match0_start_ptr };
        let match0_end = unsafe { *match0_end_ptr };
        
        printf("  Full match: position %d to %d\n\0".as_bytes().as_ptr(), 
               match0_start, match0_end);
        
        // Group 1 (username)
        let match1_start_ptr = (matches as usize + 16) as *i64;
        let match1_end_ptr = (matches as usize + 24) as *i64;
        let match1_start = unsafe { *match1_start_ptr };
        let match1_end = unsafe { *match1_end_ptr };
        
        if match1_start >= 0 {
            printf("  Username match: position %d to %d\n\0".as_bytes().as_ptr(),
                   match1_start, match1_end);
        }
        
        // Group 2 (domain)
        let match2_start_ptr = (matches as usize + 32) as *i64;
        let match2_end_ptr = (matches as usize + 40) as *i64;
        let match2_start = unsafe { *match2_start_ptr };
        let match2_end = unsafe { *match2_end_ptr };
        
        if match2_start >= 0 {
            printf("  Domain match: position %d to %d\n\0".as_bytes().as_ptr(),
                   match2_start, match2_end);
        }
    } else {
        printf("✗ Email did not match\n\0".as_bytes().as_ptr());
    }
    
    // Clean up
    unsafe { libc.free(matches); }
    unsafe { libc.regfree(regex as *mut libc.regex_t); }
    unsafe { libc.free(regex); }
}

fn test_pattern_validation() {
    printf("\n=== Pattern Validation Test ===\n\0".as_bytes().as_ptr());
    
    // Valid patterns
    test_pattern("^[0-9]+$\0", "12345\0", true);      // Numbers only
    test_pattern("^[a-zA-Z]+$\0", "Hello\0", true);   // Letters only
    test_pattern("^[a-zA-Z]+$\0", "Hello123\0", false); // Should fail
    
    // Date pattern: YYYY-MM-DD
    test_pattern("[0-9]{4}-[0-9]{2}-[0-9]{2}\0", "2025-11-02\0", true);
    
    // URL pattern (simplified)
    test_pattern("https?://[a-zA-Z0-9.-]+\0", "https://example.com\0", true);
}

fn test_pattern(pattern: *byte, text: *byte, should_match: bool) {
    let regex = unsafe { libc.malloc(64) };
    if regex as usize == 0 {
        return;
    }
    
    let compile_result = unsafe { libc.regcomp(regex as *mut libc.regex_t, 
                                                pattern, libc.REG_EXTENDED) };
    
    if compile_result != 0 {
        printf("  ✗ Failed to compile pattern\n\0".as_bytes().as_ptr());
        unsafe { libc.free(regex); }
        return;
    }
    
    let result = unsafe { libc.regexec(regex as *libc.regex_t, text, 0,
                                       0 as *mut libc.regmatch_t, 0) };
    
    let matched = result == 0;
    
    if matched == should_match {
        printf("  ✓ Pattern test passed\n\0".as_bytes().as_ptr());
    } else {
        printf("  ✗ Pattern test failed\n\0".as_bytes().as_ptr());
    }
    
    unsafe { libc.regfree(regex as *mut libc.regex_t); }
    unsafe { libc.free(regex); }
}

fn main() -> i32 {
    printf("=== POSIX Regex Test Suite ===\n\0".as_bytes().as_ptr());
    
    test_basic_match();
    test_capture_groups();
    test_pattern_validation();
    
    printf("\n=== All Tests Complete ===\n\0".as_bytes().as_ptr());
    return 0;
}
