// Test: Comprehensive Operator Overloading

trait Add { fn add(other: Self): Self; }
trait Sub { fn sub(other: Self): Self; }
trait Mul { fn mul(other: Self): Self; }
trait Eq { fn eq(other: Self): bool; }

struct Complex impl Add, Sub, Mul, Eq {
    real: f32,
    imag: f32,

    fn add(other: Complex): Complex {
        return Complex {
            real: self.real + other.real,
            imag: self.imag + other.imag
        };
    }

    fn sub(other: Complex): Complex {
        return Complex {
            real: self.real - other.real,
            imag: self.imag - other.imag
        };
    }

    fn mul(other: Complex): Complex {
        // (a + bi) * (c + di) = (ac - bd) + (ad + bc)i
        return Complex {
            real: self.real * other.real - self.imag * other.imag,
            imag: self.real * other.imag + self.imag * other.real
        };
    }

    fn eq(other: Complex): bool {
        if self.real == other.real {
            if self.imag == other.imag {
                return true;
            }
        }
        return false;
    }
}

fn main(): i32 {
    let c1 = Complex { real: 1.0, imag: 2.0 };
    let c2 = Complex { real: 3.0, imag: 4.0 };
    
    // Test operator overloading
    let c3 = c1 + c2;  // Addition
    let c4 = c1 - c2;  // Subtraction
    let c5 = c1 * c2;  // Multiplication
    
    // Comparison
    if c1 == c2 {
        return 1;
    }
    
    return 42;  // Success
}
