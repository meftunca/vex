// Test multiple generic trait implementations
contract Add<Rhs> {
    op+(other: Rhs): Self;
}

contract Mul<Rhs> {
    op*(other: Rhs): Self;
}

struct Vec2 impl Add<i32>, Add<f64>, Mul<i32> {
    x: f64,
    y: f64,
    
    // Add<i32> implementation
    fn op+(other: i32): Vec2 {
        return Vec2 { 
            x: self.x + (other as f64), 
            y: self.y + (other as f64) 
        };
    }
    
    // Add<f64> implementation
    fn op+(other: f64): Vec2 {
        return Vec2 { 
            x: self.x + other, 
            y: self.y + other 
        };
    }
    
    // Mul<i32> implementation
    fn op*(other: i32): Vec2 {
        return Vec2 { 
            x: self.x * (other as f64), 
            y: self.y * (other as f64) 
        };
    }
}

fn main(): i32 {
    let v = Vec2 { x: 2.0, y: 3.0 };
    
    // Test Add<i32>
    let v1 = v + 1;
    if v1.x as i32 != 3 {
        return 1;
    }
    if v1.y as i32 != 4 {
        return 2;
    }
    
    // Test Add<f64>
    let v2 = v + 0.5;
    if v2.x as i32 != 2 {
        return 3;
    }
    if v2.y as i32 != 3 {
        return 4;
    }
    
    // Test Mul<i32>
    let v3 = v * 2;
    if v3.x as i32 != 4 {
        return 5;
    }
    if v3.y as i32 != 6 {
        return 6;
    }
    
    return 0; // Success
}
