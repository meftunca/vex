// Test: Comparison operators (Eq, Ord contracts)
// Expected: exit code = 42

contract Eq {
    op==(rhs: Self): bool;
    op!=(rhs: Self): bool;
}

contract Ord {
    op<(rhs: Self): bool;
    op>(rhs: Self): bool;
    op<=(rhs: Self): bool;
    op>=(rhs: Self): bool;
}

struct Point impl Eq, Ord {
    x: i32,
    y: i32,
    
    op==(other: Point): bool {
        // Use builtin comparison on fields
        let x_eq = self.x == other.x;
        let y_eq = self.y == other.y;
        return x_eq && y_eq;
    }
    
    op!=(other: Point): bool {
        // Manual implementation instead of !(self == other)
        if self.x != other.x {
            return true;
        }
        return self.y != other.y;
    }
    
    op<(other: Point): bool {
        // Lexicographic ordering: compare x first, then y
        if self.x < other.x {
            return true;
        }
        if self.x > other.x {
            return false;
        }
        return self.y < other.y;
    }
    
    op>(other: Point): bool {
        return other < self;
    }
    
    op<=(other: Point): bool {
        return !(self > other);
    }
    
    op>=(other: Point): bool {
        return !(self < other);
    }
}

fn main(): i32 {
    let p1 = Point { x: 1, y: 2 };
    let p2 = Point { x: 1, y: 2 };
    let p3 = Point { x: 2, y: 1 };
    
    // Test equality (using mutable variables instead of if expressions)
    let! eq_result = 0;
    if p1 == p2 {
        eq_result = 10;
    }
    
    let! ne_result = 0;
    if p1 != p3 {
        ne_result = 10;
    }
    
    // Test ordering
    let! lt_result = 0;
    if p1 < p3 {
        lt_result = 10;
    }
    
    let! le_result = 0;
    if p1 <= p2 {
        le_result = 10;
    }
    
    // Builtin types should also work
    let! builtin_eq = 0;
    if 5 == 5 {
        builtin_eq = 1;
    }
    
    let! builtin_lt = 0;
    if 3 < 7 {
        builtin_lt = 1;
    }
    
    // Total: 10 + 10 + 10 + 10 + 1 + 1 = 42
    return eq_result + ne_result + lt_result + le_result + builtin_eq + builtin_lt;
}
