// Closure compilation and code generation

use crate::codegen_ast::ASTCodeGen;
use inkwell::types::BasicType;
use inkwell::values::{BasicValueEnum, FunctionValue, PointerValue};
use vex_ast::*;

impl<'ctx> ASTCodeGen<'ctx> {
    /// Find free variables in an expression (variables used but not defined in params)
    pub(super) fn find_free_variables(&self, expr: &Expression, params: &[Param]) -> Vec<String> {
        use std::collections::HashSet;

        let param_names: HashSet<String> = params.iter().map(|p| p.name.clone()).collect();
        let mut free_vars = Vec::new();
        let mut visited = HashSet::new();

        self.collect_variables(expr, &param_names, &mut free_vars, &mut visited);
        free_vars
    }

    /// Recursively collect variable references
    fn collect_variables(
        &self,
        expr: &Expression,
        params: &std::collections::HashSet<String>,
        free_vars: &mut Vec<String>,
        visited: &mut std::collections::HashSet<String>,
    ) {
        match expr {
            Expression::Ident(name) => {
                // If it's not a parameter and not already visited
                if !params.contains(name) && !visited.contains(name) {
                    // Check if it's a local variable (not a function name)
                    if self.variables.contains_key(name) {
                        visited.insert(name.clone());
                        free_vars.push(name.clone());
                    }
                }
            }
            Expression::Binary {
                span_id: _,
                left,
                right,
                ..
            } => {
                self.collect_variables(left, params, free_vars, visited);
                self.collect_variables(right, params, free_vars, visited);
            }
            Expression::Unary {
                span_id: _, expr, ..
            } => {
                self.collect_variables(expr, params, free_vars, visited);
            }
            Expression::Call {
                func,
                args,
                ..
            } => {
                self.collect_variables(func, params, free_vars, visited);
                for arg in args {
                    self.collect_variables(arg, params, free_vars, visited);
                }
            }
            Expression::MethodCall { receiver, args, .. } => {
                self.collect_variables(receiver, params, free_vars, visited);
                for arg in args {
                    self.collect_variables(arg, params, free_vars, visited);
                }
            }
            Expression::FieldAccess { object, .. } => {
                self.collect_variables(object, params, free_vars, visited);
            }
            Expression::Index { object, index } => {
                self.collect_variables(object, params, free_vars, visited);
                self.collect_variables(index, params, free_vars, visited);
            }
            Expression::Array(elements) => {
                for elem in elements {
                    self.collect_variables(elem, params, free_vars, visited);
                }
            }
            Expression::TupleLiteral(elements) => {
                for elem in elements {
                    self.collect_variables(elem, params, free_vars, visited);
                }
            }
            Expression::StructLiteral { fields, .. } => {
                for (_, expr) in fields {
                    self.collect_variables(expr, params, free_vars, visited);
                }
            }
            Expression::Match { value, arms } => {
                self.collect_variables(value, params, free_vars, visited);
                for arm in arms {
                    if let Some(guard) = &arm.guard {
                        self.collect_variables(guard, params, free_vars, visited);
                    }
                    self.collect_variables(&arm.body, params, free_vars, visited);
                }
            }
            Expression::Block { return_expr, .. } => {
                // For blocks, we mainly care about the return expression
                // TODO: Handle statement expressions more thoroughly
                if let Some(ret) = return_expr {
                    self.collect_variables(ret, params, free_vars, visited);
                }
            }
            _ => {} // Literals, other expressions
        }
    }

    /// Compile closure/lambda expression: |x: i32| x * 2
    /// Returns a closure struct containing function pointer and captured environment
    pub(crate) fn compile_closure(
        &mut self,
        params: &[Param],
        return_type: &Option<Type>,
        body: &Expression,
        capture_mode: &CaptureMode,
    ) -> Result<BasicValueEnum<'ctx>, String> {
        // Generate unique closure name
        static mut CLOSURE_COUNTER: usize = 0;
        let closure_name = unsafe {
            CLOSURE_COUNTER += 1;
            format!("__closure_{}", CLOSURE_COUNTER)
        };

        // Step 1: Detect free variables (captured from environment)
        let free_vars = self.find_free_variables(body, params);

        eprintln!(
            "üîç Closure {}: Found {} free variables: {:?}, capture_mode: {:?}",
            closure_name,
            free_vars.len(),
            free_vars,
            capture_mode
        );

        // Step 2: Create environment struct type if we have captures
        let env_struct_type = if !free_vars.is_empty() {
            let mut field_types = Vec::new();
            for var_name in &free_vars {
                if let Some(var_type) = self.variable_types.get(var_name) {
                    field_types.push(*var_type);
                } else {
                    return Err(format!(
                        "Cannot find type for captured variable: {}",
                        var_name
                    ));
                }
            }
            Some(self.context.struct_type(&field_types, false))
        } else {
            None
        };

        // Step 3: Build parameter types for closure function
        // If we have captures, add environment pointer as first parameter
        let mut param_basic_types = Vec::new();
        if env_struct_type.is_some() {
            // Add environment pointer as hidden first parameter
            param_basic_types.push(
                self.context
                    .ptr_type(inkwell::AddressSpace::default())
                    .into(),
            );
        }

        // Add user-defined parameters - with type inference for Infer types
        let mut inferred_params = Vec::new();
        for param in params {
            let inferred_ty = if matches!(param.ty, Type::Infer(_)) {
                // Try to infer parameter type from usage in body
                if let Some(inferred) = self.infer_param_type_from_body(&param.name, body) {
                    eprintln!("  ‚ú® Inferred parameter '{}' type: {:?}", param.name, inferred);
                    inferred
                } else {
                    eprintln!("  ‚ö†Ô∏è  Could not infer type for parameter '{}', defaulting to i32", param.name);
                    Type::I32
                }
            } else {
                param.ty.clone()
            };
            
            let param_ty = self.ast_type_to_llvm(&inferred_ty);
            param_basic_types.push(param_ty.into());
            
            // Store updated param with inferred type
            inferred_params.push(Param {
                name: param.name.clone(),
                ty: inferred_ty,
                default_value: param.default_value.clone(),
            });
        }

        // Determine return type
        let ret_type = if let Some(ty) = return_type {
            self.ast_type_to_llvm(ty)
        } else {
            // Try to infer from body expression type
            if let Some(inferred) = self.infer_return_type_from_body(body) {
                eprintln!("  ‚ú® Inferred return type: {:?}", inferred);
                self.ast_type_to_llvm(&inferred)
            } else {
                eprintln!("  ‚ö†Ô∏è  Could not infer return type, defaulting to i32");
                self.context.i32_type().into()
            }
        };

        // Create function type
        let fn_type = ret_type.fn_type(&param_basic_types, false);

        // Create the closure function
        let closure_fn = self.module.add_function(&closure_name, fn_type, None);

        // Save current function and builder state
        let saved_fn = self.current_function;
        let saved_variables = self.variables.clone();

        // Set current function to closure
        self.current_function = Some(closure_fn);

        // Create entry block for closure
        let entry = self.context.append_basic_block(closure_fn, "entry");
        self.builder.position_at_end(entry);

        // Step 4: Load captured variables from environment struct
        let mut param_offset = 0;
        if let Some(env_type) = env_struct_type {
            // Get environment pointer (first parameter)
            let env_ptr = closure_fn
                .get_nth_param(0)
                .ok_or("Failed to get environment pointer")?
                .into_pointer_value();
            env_ptr.set_name("env");

            eprintln!(
                "üì¶ Loading {} captured variables from environment",
                free_vars.len()
            );

            // Load each captured variable from struct
            for (idx, var_name) in free_vars.iter().enumerate() {
                let var_type = self
                    .variable_types
                    .get(var_name)
                    .ok_or_else(|| format!("Type not found for captured variable: {}", var_name))?;

                // GEP to get pointer to field
                let field_ptr = unsafe {
                    self.builder
                        .build_in_bounds_gep(
                            env_type,
                            env_ptr,
                            &[
                                self.context.i32_type().const_int(0, false),
                                self.context.i32_type().const_int(idx as u64, false),
                            ],
                            &format!("{}_ptr", var_name),
                        )
                        .map_err(|e| format!("Failed to GEP for {}: {}", var_name, e))?
                };

                // Load the value
                let loaded_value = self
                    .builder
                    .build_load(*var_type, field_ptr, var_name)
                    .map_err(|e| format!("Failed to load {}: {}", var_name, e))?;

                // Allocate local stack space and store
                let alloca = self
                    .builder
                    .build_alloca(*var_type, &format!("{}_local", var_name))
                    .map_err(|e| format!("Failed to allocate {}: {}", var_name, e))?;

                self.builder
                    .build_store(alloca, loaded_value)
                    .map_err(|e| format!("Failed to store {}: {}", var_name, e))?;

                // Register in variables map
                self.variables.insert(var_name.clone(), alloca.into());

                eprintln!("  ‚úì Loaded captured variable: {}", var_name);
            }

            param_offset = 1; // Skip environment pointer when processing user params
        }

        // Register closure parameters in scope
        eprintln!("üìù Registering {} closure parameters (param_offset={})", inferred_params.len(), param_offset);
        for (i, param) in inferred_params.iter().enumerate() {
            let llvm_param = closure_fn
                .get_nth_param((i + param_offset) as u32)
                .ok_or_else(|| format!("Failed to get parameter {} for closure", i))?;

            eprintln!("  Param {}: name={}, type={:?}", i, param.name, param.ty);

            // Name the parameter
            if let BasicValueEnum::IntValue(iv) = llvm_param {
                iv.set_name(&param.name);
            } else if let BasicValueEnum::FloatValue(fv) = llvm_param {
                fv.set_name(&param.name);
            } else if let BasicValueEnum::PointerValue(pv) = llvm_param {
                pv.set_name(&param.name);
            }

            // Allocate stack space and store parameter
            let param_ty = self.ast_type_to_llvm(&param.ty);
            let alloca = self
                .builder
                .build_alloca(param_ty, &param.name)
                .map_err(|e| format!("Failed to allocate parameter {}: {}", param.name, e))?;

            self.builder
                .build_store(alloca, llvm_param)
                .map_err(|e| format!("Failed to store parameter {}: {}", param.name, e))?;

            // Store in variables map (as pointer)
            self.variables.insert(param.name.clone(), alloca.into());
            self.variable_types.insert(param.name.clone(), param_ty);
        }

        // Compile closure body
        let body_value = self.compile_expression(body)?;

        // Build return
        self.builder
            .build_return(Some(&body_value))
            .map_err(|e| format!("Failed to build return in closure: {}", e))?;

        // Restore previous function and scope
        self.current_function = saved_fn;
        self.variables = saved_variables;

        // Restore builder position to valid insertion point
        if let Some(current_fn) = self.current_function {
            // Find a valid basic block for insertion
            let mut found_valid_block = false;
            
            // First try to find an unterminated block
            let mut bb_iter = current_fn.get_first_basic_block();
            while let Some(bb) = bb_iter {
                if bb.get_terminator().is_none() {
                    self.builder.position_at_end(bb);
                    found_valid_block = true;
                    break;
                }
                bb_iter = bb.get_next_basic_block();
            }
            
            // If all blocks are terminated, position at end of last block anyway
            // (we'll create new blocks if needed during subsequent compilation)
            if !found_valid_block {
                if let Some(bb) = current_fn.get_last_basic_block() {
                    self.builder.position_at_end(bb);
                }
            }
        }

        // Step 5: Create environment struct instance and populate with captured values
        if let Some(env_type) = env_struct_type {
            eprintln!(
                "üèóÔ∏è  Creating environment struct with {} captures",
                free_vars.len()
            );

            // Allocate space for environment struct
            let env_alloca = self
                .builder
                .build_alloca(env_type, "closure_env")
                .map_err(|e| format!("Failed to allocate environment: {}", e))?;

            // Store each captured variable into the struct
            for (idx, var_name) in free_vars.iter().enumerate() {
                let var_ptr = self
                    .variables
                    .get(var_name)
                    .ok_or_else(|| format!("Captured variable not found: {}", var_name))?;

                let var_type = self
                    .variable_types
                    .get(var_name)
                    .ok_or_else(|| format!("Type not found for captured variable: {}", var_name))?;

                // Load current value
                let var_value = self
                    .builder
                    .build_load(*var_type, *var_ptr, var_name)
                    .map_err(|e| format!("Failed to load {}: {}", var_name, e))?;

                // GEP to field in struct
                let field_ptr = unsafe {
                    self.builder
                        .build_in_bounds_gep(
                            env_type,
                            env_alloca,
                            &[
                                self.context.i32_type().const_int(0, false),
                                self.context.i32_type().const_int(idx as u64, false),
                            ],
                            &format!("env_{}_ptr", var_name),
                        )
                        .map_err(|e| format!("Failed to GEP for {}: {}", var_name, e))?
                };

                // Store into struct field
                self.builder
                    .build_store(field_ptr, var_value)
                    .map_err(|e| format!("Failed to store {} to env: {}", var_name, e))?;

                eprintln!("  ‚úì Captured variable: {} = {:?}", var_name, var_value);
            }

            // Step 6: Create fat pointer struct { fn_ptr, env_ptr }
            // This allows us to pass both function and environment together
            let fn_ptr = closure_fn.as_global_value().as_pointer_value();
            let env_ptr = env_alloca; // Environment struct pointer

            // Store mapping for later use during function calls
            self.closure_envs.insert(fn_ptr, env_ptr);

            eprintln!("‚úÖ Created closure with environment binding");
            eprintln!("   Function: {:?}, Environment: {:?}", fn_ptr, env_ptr);

            // Step 7: Generate closure struct with trait impl
            self.generate_closure_struct(
                &closure_name,
                params,
                return_type,
                capture_mode,
                closure_fn,
                Some(env_alloca),
            )?;

            // For now, return function pointer
            // When this closure is called, we'll look up its environment in closure_envs
            Ok(fn_ptr.into())
        } else {
            // No captures, just return function pointer
            eprintln!("‚úÖ Created closure without captures (pure function)");

            // Generate closure struct even without captures (for trait impl)
            self.generate_closure_struct(
                &closure_name,
                params,
                return_type,
                capture_mode,
                closure_fn,
                None,
            )?;

            Ok(closure_fn.as_global_value().as_pointer_value().into())
        }
    }

    /// Generate closure struct with trait implementation
    /// Creates: struct __Closure_1 impl Callable(i32): i32 { fn_ptr, env_ptr }
    pub(super) fn generate_closure_struct(
        &mut self,
        closure_name: &str,
        params: &[Param],
        return_type: &Option<Type>,
        capture_mode: &CaptureMode,
        _closure_fn: FunctionValue<'ctx>,
        _env_ptr: Option<PointerValue<'ctx>>,
    ) -> Result<(), String> {
        // Note: Field, Function, Receiver, Struct, Type are already imported via vex_ast::*

        // Determine trait name based on capture mode
        let trait_name = match capture_mode {
            CaptureMode::Immutable | CaptureMode::Infer => "Callable",
            CaptureMode::Mutable => "CallableMut",
            CaptureMode::Once => "CallableOnce",
        };

        eprintln!(
            "üèóÔ∏è  Generating closure struct: {} impl {}",
            closure_name, trait_name
        );

        // Create struct type name from closure name
        let struct_name = format!(
            "{}{}",
            &closure_name[0..1].to_uppercase(),
            &closure_name[1..]
        );

        // Create trait method: call/call_mut/call_once
        let method_name = match capture_mode {
            CaptureMode::Immutable | CaptureMode::Infer => "call",
            CaptureMode::Mutable => "call_mut",
            CaptureMode::Once => "call_once",
        };

        // Build method parameters from closure parameters (just copy the vector)
        let method_params: Vec<Param> = params.to_vec();

        // Determine receiver mutability
        let is_mutable = matches!(capture_mode, CaptureMode::Mutable);

        // Create method with receiver
        let method = Function {
            is_async: false,
            is_gpu: false,
            is_mutable, // ‚≠ê NEW: Method mutability matches closure capture mode
            is_operator: false, // Closures are not operators
            receiver: Some(Receiver {
                name: "self".to_string(), // Generated closure struct methods use 'self'
                is_mutable,
                ty: Type::Reference(Box::new(Type::Named(struct_name.clone())), is_mutable),
            }),
            name: method_name.to_string(),
            type_params: vec![],
            const_params: vec![],
            where_clause: vec![],
            params: method_params,
            return_type: return_type.clone(),
            body: Block {
                statements: vec![], // Empty body - will be generated in codegen
            },
            is_variadic: false,
            variadic_type: None,
        };

        // Create struct definition with trait impl (no fields - managed by LLVM)
        // The actual closure struct layout (fn_ptr + env_ptr) is internal to LLVM
        let struct_def = Struct {
            name: struct_name.clone(),
            type_params: vec![],
            const_params: vec![],
            where_clause: vec![],
            policies: vec![], // No policies for generated closure structs
            impl_traits: vec![TraitImpl {
                name: trait_name.to_string(),
                type_args: vec![],
            }],
            associated_type_bindings: vec![], // No associated types for closures
            fields: vec![],                   // Internal LLVM representation
            methods: vec![method],
        };

        // Register struct in AST definitions
        self.struct_ast_defs.insert(struct_name.clone(), struct_def);

        eprintln!(
            "‚úÖ Generated closure struct: {} impl {}",
            struct_name, trait_name
        );

        Ok(())
    }

    /// Infer parameter type from usage in closure body
    fn infer_param_type_from_body(&self, param_name: &str, body: &Expression) -> Option<Type> {
        match body {
            Expression::Binary { left, right, op, .. } => {
                // Check if parameter is used in binary expression
                if let Expression::Ident(name) = &**left {
                    if name == param_name {
                        // Infer from right side
                        return self.infer_expr_type(right);
                    }
                }
                if let Expression::Ident(name) = &**right {
                    if name == param_name {
                        // Infer from left side
                        return self.infer_expr_type(left);
                    }
                }
                // Recurse into both sides
                self.infer_param_type_from_body(param_name, left)
                    .or_else(|| self.infer_param_type_from_body(param_name, right))
            }
            Expression::Call { func, args, .. } => {
                // Check arguments for parameter usage
                for arg in args {
                    if let Some(ty) = self.infer_param_type_from_body(param_name, arg) {
                        return Some(ty);
                    }
                }
                self.infer_param_type_from_body(param_name, func)
            }
            Expression::Ident(name) if name == param_name => {
                // Direct usage, can't infer from this alone
                None
            }
            Expression::Block { statements, .. } => {
                // Check last expression in block
                if let Some(Statement::Expression(expr)) = statements.last() {
                    return self.infer_param_type_from_body(param_name, expr);
                }
                None
            }
            _ => None,
        }
    }

    /// Infer return type from closure body
    fn infer_return_type_from_body(&self, body: &Expression) -> Option<Type> {
        match body {
            Expression::Block { statements, .. } => {
                // Get type of last expression
                if let Some(Statement::Expression(expr)) = statements.last() {
                    return self.infer_expr_type(expr);
                }
                None
            }
            _ => self.infer_expr_type(body),
        }
    }

    /// Infer type from expression structure
    fn infer_expr_type(&self, expr: &Expression) -> Option<Type> {
        match expr {
            Expression::IntLiteral(_) => Some(Type::I32),
            Expression::FloatLiteral(_) => Some(Type::F64),
            Expression::BoolLiteral(_) => Some(Type::Bool),
            Expression::StringLiteral(_) => Some(Type::String),
            Expression::Binary { left, right, op, .. } => {
                use vex_ast::BinaryOp::*;
                match op {
                    Add | Sub | Mul | Div | Mod | Pow => {
                        // Arithmetic - propagate operand types
                        self.infer_expr_type(left).or_else(|| self.infer_expr_type(right))
                    }
                    Eq | NotEq | Lt | LtEq | Gt | GtEq | And | Or => Some(Type::Bool),
                    _ => None,
                }
            }
            Expression::Ident(_name) => {
                // Variable type lookup disabled - LLVM pointer types don't map back to Type enum easily
                // This is fine for closure inference since we can infer from literals/operators
                None
            }
            Expression::Call { func, .. } => {
                // Try to infer from function signature
                if let Expression::Ident(fn_name) = &**func {
                    // Check builtin functions
                    match fn_name.as_str() {
                        "i32_to_string" | "f64_to_string" | "bool_to_string" => {
                            Some(Type::String)
                        }
                        _ => None,
                    }
                } else {
                    None
                }
            }
            Expression::Block { statements, .. } => {
                if let Some(Statement::Expression(expr)) = statements.last() {
                    return self.infer_expr_type(expr);
                }
                None
            }
            _ => None,
        }
    }

}
