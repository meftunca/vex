// Test file for Vex type system: Primitive Types
// This file tests all primitive types

fn main(): i64 {
    // Signed integers (using smaller values for i128 test)
    let i8_val: i8 = -128;
    let i16_val: i16 = -32768;
    let i32_val: i32 = -2147483648;
    let i64_val: i64 = -9223372036854775808;
    let i128_val: i128 = -170141183460469231731687303715884105728;

    // Unsigned integers (using smaller values for u64/u128 test)
    let u8_val: u8 = 255;
    let u16_val: u16 = 65535;
    let u32_val: u32 = 4294967295;
    let u64_val: u64 = 18446744073709551615;
    let u128_val: u128 = 1234567890;

    // Floating point
    let f16_val: f16 = 1.5;
    let f32_val: f32 = 3.14159;
    let f64_val: f64 = 2.718281828459045;

    // Other primitives
    let bool_val: bool = true;
    let string_val: string = "Hello, Vex!";
    let byte_val: byte = 42;
    let nil_val: nil = nil;
    let error_val: error = nil;

    // Type inference
    let inferred_i32 = 42;        // i32
    let inferred_f64 = 3.14;      // f64
    let inferred_bool = false;    // bool
    let inferred_string = "test"; // string

    // Edge cases: Boundary values
    let i8_min: i8 = -128;
    let i8_max: i8 = 127;
    let u8_min: u8 = 0;
    let u8_max: u8 = 255;

    let i32_min: i32 = -2147483648;
    let i32_max: i32 = 2147483647;
    let u32_min: u32 = 0;
    let u32_max: u32 = 4294967295;

    // Floating point edge cases
    let f64_zero: f64 = 0.0;
    let f64_neg_zero: f64 = -0.0;
    let f64_inf: f64 = 1.0 / 0.0;  // Infinity (if supported)
    let f64_neg_inf: f64 = -1.0 / 0.0;
    let f64_nan: f64 = 0.0 / 0.0;  // NaN (if supported)

    // String edge cases
    let empty_string: string = "";
    let single_char: string = "a";
    let unicode_string: string = "Hello, 世界!";  // Unicode if supported
    let long_string: string = "This is a very long string to test string handling in Vex language implementation.";

    // Bool edge cases (only true/false, no implicit conversion)
    let bool_true: bool = true;
    let bool_false: bool = false;

    // Nil and error
    let nil_test: nil = nil;
    let error_test: error = nil;  // Error is typically nil or specific error
    return i64_val;
    //return i8_max + u8_max ;
}