// Test file for Vex type system: Compound Types
// This file tests arrays, tuples, and slices

fn main() {
    // Fixed-size arrays
    let arr1: [i32; 5] = [1, 2, 3, 4, 5];
    let arr2: [i32; 10] = [0; 10];  // Repeat syntax

    // Tuples
    let pair: (i32, string) = (42, "answer");
    let triple: (f64, bool, i32) = (3.14, true, 100);
    // let single: (i32,) = (42,);  // Single element tuple - may not be supported

    // Access elements
    let first = arr1[0];
    let second = pair.0;
    let third = triple.2;

    // Tuple destructuring - commented out as it may not be implemented yet
    // let (x, y) = pair;
    // let (a, b, c) = triple;

    // Nested compounds - commented out as nested array types may not be supported yet
    // let nested: [(i32, string); 2] = [(1, "one"), (2, "two")];
    // let tuple_array: ([i32; 3], bool) = ([1, 2, 3], true);

    // Type inference for compounds
    let inferred_arr = [1, 2, 3];  // [i32; 3]
    let inferred_tuple = (1, "hello");  // (i32, string)

    // Edge cases: Empty arrays and tuples - commented out as empty arrays may not be supported
    // let empty_arr: [i32; 0] = [];
    // let empty_tuple: () = ();  // Unit tuple

    // Large arrays (if supported) - commented out
    // let large_arr: [i32; 100] = [0; 100];

    // Deeply nested structures - commented out
    // let nested_tuple: (((i32, string), bool), [f64; 2]) = (((42, "nested"), true), [3.14, 2.71]);

    // Array access edge cases (would cause runtime errors if out of bounds)
    // let out_of_bounds = arr1[10];  // Index 10 on array of size 5 - runtime error
    let last_element = arr1[4];  // Valid last index

    // Tuple with many elements
    let many_tuple: (i32, i32, i32, i32, i32, i32, i32, i32, i32, i32) = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
    let tenth = many_tuple.9;

    // Array of tuples - commented out
    // let arr_of_tuples: [(i32, string); 3] = [(1, "a"), (2, "b"), (3, "c")];

    // return first; // + x + a + last_element + tenth;
}