// Test file for Vex variables and constants: Variables
// This file tests variable declarations, mutability, and shadowing

// Function parameters are immutable by default
fn test_func(param: i32) {
    // param = param + 1;  // ERROR: Cannot mutate parameter
}

fn main(): i32 {
    // Immutable variables (default)
    let x = 42;
    let name = "Alice";
    let pi = 3.14159;

    // Cannot reassign immutable variables
    // x = 100;  // ERROR: Cannot reassign immutable variable

    // Mutable variables (explicit !)
    let! counter = 0;
    let! balance = 1000.0;

    counter = counter + 1;  // OK
    balance = 500.0;        // OK

    // Type annotations
    let y: i32 = 42;
    let user_name: string = "Bob";
    let flag: bool = true;

    // Type inference
    let z = 42;        // Inferred as i32
    let w = 3.14;      // Inferred as f64

    // Shadowing
    let shadowed = 5;
    let shadowed = shadowed + 1;     // Shadows previous
    let shadowed = "text";           // Different type allowed

    // Function parameters are immutable by default
    test_func(10);

    // Edge cases: Complex shadowing
    let value = 10;
    // Note: Standalone blocks not supported, shadowing tested in if blocks
    if true {
        let inner_value = 20;  // Different name to avoid borrow checker issues
        let inner_value2 = 30;  // Shadows inner_value
        // Inner values are scoped
    }
    // Outer value is still 10

    let! mutable_var = 100;
    let mutable_var = 200;  // Immutable shadows mutable
    // Now mutable_var is immutable

    // Shadowing with different types in sequence
    let changing = 1;
    let changing = 2.5;      // i32 to f64
    let changing = "three";  // f64 to string
    let changing = true;     // string to bool

    // Shadowing in loops
    for let! i = 0; i < 3; i = i + 1 {
        let loop_var = i * 2;
        // loop_var shadows in each iteration
    }

    // Mutable variable shadowing edge case
    let! outer_mut = 50;
    if true {
        let! inner_mut = 60;  // Different name to avoid borrow checker issues
        inner_mut = 70;       // Modifies inner
    }
    // outer_mut is still 50

    return counter + y + value + mutable_var as i32;
}