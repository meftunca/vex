// Test file for Vex functions and methods: Function Syntax
// This file tests basic function syntax and entry points

// Basic function
fn add(x: i32, y: i32): i32 {
    return x + y;
}

// Function with no return type (returns nil)
fn greet(name: string) {
    // No explicit return, returns nil
}

// Function with multiple parameters
fn calculate(a: i32, b: i32, operation: string): i32 {
    match operation {
        "add" => { return a + b; }
        "subtract" => { return a - b; }
        "multiply" => { return a * b; }
        _ => { return 0; }
    }
}

// Recursive function
fn factorial(n: i32): i32 {
    if n <= 1 {
        return 1;
    }
    return n * factorial(n - 1);
}

// Function with early return
fn early_return_test(x: i32): i32 {
    if x < 0 {
        return -1;
    }
    if x == 0 {
        return 0;
    }
    return x * 2;
}
// Function with many parameters
fn many_params(a: i32, b: i32, c: i32, d: i32, e: i32, f: i32, g: i32, h: i32, i: i32, j: i32): i32 {
    return a + b + c + d + e + f + g + h + i + j;
}
// Function returning complex expression
fn complex_expr(x: i32, y: i32): i32 {
    return (x + y) * (x - y) / (x == y ? 1 : (x - y));
}
// Entry point
fn main(): i32 {
    let sum = add(5, 3);
    greet("Vex");

    let calc_result = calculate(10, 5, "multiply");
    let fact = factorial(5);
    let early = early_return_test(10);

    // Edge cases: Deep recursion (may cause stack overflow)
    // let deep_fact = factorial(1000);  // Very deep recursion



    let many_result = many_params(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

    // Nested function calls
    let nested = add(calculate(2, 3, "add"), early_return_test(5));

    // Complex return expression
    let complex_return = calculate(add(1, 2), factorial(3), "multiply");

 

    let complex = complex_expr(10, 5);

    return sum + calc_result + fact + early + many_result + nested + complex_return + complex;
}