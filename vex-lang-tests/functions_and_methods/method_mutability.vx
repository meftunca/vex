// Test file for Vex functions and methods: Method Mutability
// This file tests inline and external method definitions and calls

// Struct with inline methods
struct Point {
    x: i32,
    y: i32,

    // Immutable inline method
    fn distance(): f64 {
        return (self.x * self.x + self.y * self.y) as f64;
    }

    // Mutable inline method
    fn move_to(new_x: i32, new_y: i32)! {
        self.x = new_x;
        self.y = new_y;
    }

    // Mutable method with parameters
    fn translate(dx: i32, dy: i32)! {
        self.x = self.x + dx;
        self.y = self.y + dy;
    }
}

// External immutable method
fn (p: &Point) to_string(): string {
    return "(" + p.x.to_string() + ", " + p.y.to_string() + ")";
}

// External mutable method
fn (p: &Point!) scale(factor: i32) {
    p.x = p.x * factor;
    p.y = p.y * factor;
}

// Another struct for testing
struct Counter {
    value: i32,

    // Inline mutable method
    fn increment()! {
        self.value = self.value + 1;
    }

    // Inline method returning self
    fn doubled(): i32 {
        return self.value * 2;
    }
}

// Edge cases: Complex receivers
struct ComplexReceiver {
    points: [Point; 2],
    count: i32,

    fn add_point(p: Point)! {
        if self.count == 0 {
            self.points[0] = p;
            self.count = self.count + 1;
        } elif self.count == 1 {
            self.points[1] = p;
            self.count = self.count + 1;
        }
    }

    fn total_distance(): f64 {
        let d1 = self.points[0].distance();
        let d2 = self.points[1].distance();
        return d1 + d2;
    }
}

// Self in different contexts
struct SelfTest {
    value: i32,

    fn modify_self()! {
        self.value = self.value + 10;
    }

    fn use_self(): i32 {
        return self.value * 2;
    }
}

// Method calls on references
fn external_on_ref(cr: &ComplexReceiver): i32 {
    return cr.count;
}

fn main(): i32 {
    // Test inline methods
    let! p_mut = Point { x: 0, y: 0 };
    let dist = p_mut.distance();  // Immutable call on mutable variable
    p_mut.move_to(10, 20);   // Mutable call (no ! in call)
    p_mut.translate(5, 5);   // Another mutable call

    // Test external methods
    // let str_repr = p_mut.to_string();  // External immutable - skip for now (string ops may cause borrow issues)
    p_mut.scale(2);                    // External mutable

    // Test counter
    let! counter = Counter { value: 0 };
    counter.increment();
    counter.increment();
    let doubled = counter.doubled();

    let! complex = ComplexReceiver { points: [Point { x: 0, y: 0 }, Point { x: 0, y: 0 }], count: 0 };
    complex.add_point(Point { x: 3, y: 4 });
    complex.add_point(Point { x: 6, y: 8 });
    let total_dist = complex.total_distance();
    let count_val = complex.count;  // Get count before borrowing
    
    let count_ref = external_on_ref(&complex);

    let! self_test = SelfTest { value: 5 };
    self_test.modify_self();
    let self_result = self_test.use_self();

    return dist as i32 + p_mut.x + p_mut.y + counter.value + doubled + total_dist as i32 + count_val + count_ref + self_result;
}