// Test file for Vex enums: Builtin Enums
// This file tests Option<T> and Result<T, E> enums

enum Option<T> {
    Some(T),
    None,
}

enum Result<T, E> {
    Ok(T),
    Err(E),
}

fn main(): i32 {
    // Option usage
    let some_value = Option.Some(42);
    let none_value = Option.None;
    let some_string = Option.Some("hello");

    // Result usage
    let success = Result.Ok(100);
    let failure = Result.Err("operation failed");
    let string_result = Result.Ok("success");

    // Pattern matching with Option
    let option_value = match some_value {
        Option.Some(value) => { value }
        Option.None => { 0 }
    };

    let option_string = match some_string {
        Option.Some(text) => { text }
        Option.None => { "none" }
    };

    // Pattern matching with Result
    let result_value = match success {
        Result.Ok(value) => { value }
        Result.Err(error) => { 0 }
    };

    let result_string = match string_result {
        Result.Ok(text) => { text }
        Result.Err(error) => { "error" }
    };

    // Functions returning Option
    let found = find_user(42);
    let not_found = find_user(999);

    let user_id = match found {
        Option.Some(id) => { id }
        Option.None => { 0 }
    };

    // Functions returning Result
    let division_ok = divide(10, 2);
    let division_err = divide(10, 0);

    let quotient = match division_ok {
        Result.Ok(value) => { value }
        Result.Err(msg) => { 0 }
    };

    return option_value + result_value + user_id + quotient;
}

fn find_user(id: i32): Option<i32> {
    if id == 42 {
        return Option.Some(id);
    }
    return Option.None;
}

fn divide(a: i32, b: i32): Result<i32, string> {
    if b == 0 {
        return Result.Err("Division by zero");
    }
    return Result.Ok(a / b);
}