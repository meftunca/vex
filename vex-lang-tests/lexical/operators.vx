// Test file for Vex lexical structure: Operators
// This file tests all operator types

// Struct for testing member access
struct Point { x: i32, y: i32 }

fn main(): i32 {
    // Arithmetic operators
    let a = 10 + 5;   // +
    let b = 10 - 5;   // -
    let c = 10 * 5;   // *
    let d = 10 / 5;   // /
    let e = 10 % 3;   // %

    // Comparison operators
    let f = a == b;   // ==
    let g = a != b;   // !=
    let h = a < b;    // <
    let i = a <= b;   // <=
    let j = a > b;    // >
    let k = a >= b;   // >=

    // Logical operators
    let l = true && false;  // &&
    let m = true || false;  // ||
    let n = !true;          // !

    // Bitwise operators
    let o = 5 & 3;    // &
    let p = 5 | 3;    // |
    let q = 5 ^ 3;    // ^
    let r = 5 << 1;   // <<
    let s = 5 >> 1;   // >>

    // Assignment operators
    let! t = 10;
    t = 20;           // =
    t += 5;           // +=
    t -= 5;           // -=
    t *= 2;           // *=
    t /= 2;           // /=
    t %= 3;           // %=
    t &= 3;           // &=
    t |= 3;           // |=
    t ^= 3;           // ^=
    t <<= 1;          // <<=
    t >>= 1;          // >>=

    // Range operators
    let range1 = 0..10;   // ..
    let range2 = 0..=10;  // ..=

    // Member access (dot operator)
    let point = Point { x: 1, y: 2 };
    let x_val = point.x;  // .

    // Edge cases: Operator precedence and associativity
    let precedence1 = 2 + 3 * 4;       // Should be 14 (multiplication first)
    let precedence2 = (2 + 3) * 4;     // Should be 20 (parentheses)
    let precedence3 = 10 - 5 - 2;      // Should be 3 (left associative)
    let precedence4 = 2 << 1 + 1;      // Should be 8 (addition first, then shift)
    let precedence5 = 10 & 7 | 3;      // Bitwise AND then OR

    // Complex expressions
    let complex = a + b * c - d / e % f;
    let logical_chain = (a > 0) && (b < 10) || (c == 5);
    let bitwise_chain = (5 & 3) | (7 ^ 2) & (10 >> 1);

    // Test successful - return 0
    return 0;
}