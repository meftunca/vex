// Test file for Vex control flow: Loops
// This file tests for and while loops

fn main(): i32 {
    let! sum = 0;

    // C-style for loop
    for let i = 0; i < 10; i = i + 1 {
        sum = sum + i;
    }

    // For loop with different step
    let! product = 1;
    for let! i = 1; i <= 5; i = i + 1 {
        product = product * i;
    }

    // Nested for loops
    let! nested_sum = 0;
    for let! i = 0; i < 3; i = i + 1 {
        for let! j = 0; j < 3; j = j + 1 {
            nested_sum = nested_sum + (i * j);
        }
    }

    // While loop
    let! counter = 0;
    let! while_sum = 0;
    while counter < 10 {
        while_sum = while_sum + counter;
        counter = counter + 1;
    }

    // While with complex condition
    let! x = 10;
    let! iterations = 0;
    while x > 0 && iterations < 20 {
        x = x - 1;
        iterations = iterations + 1;
    }

    // Infinite loop with break
    let! infinite_counter = 0;
    while true {
        infinite_counter = infinite_counter + 1;
        if infinite_counter >= 5 {
            break;
        }
    }

    // Loop with continue
    let! continue_sum = 0;
    for let! i = 0; i < 10; i = i + 1 {
        if i % 2 == 0 {
            continue;  // Skip even numbers
        }
        continue_sum = continue_sum + i;
    }

    // Edge cases: Deeply nested loops
    let! deep_nested = 0;
    for let! a = 0; a < 2; a = a + 1 {
        for let! b = 0; b < 2; b = b + 1 {
            for let! c = 0; c < 2; c = c + 1 {
                for let! d = 0; d < 2; d = d + 1 {
                    deep_nested = deep_nested + 1;
                }
            }
        }
    }

    // Loop with very large bounds (may be slow)
    let! large_loop_sum = 0;
    for let! i = 0; i < 1000; i = i + 1 {
        large_loop_sum = large_loop_sum + 1;
    }

    // While loop with multiple break conditions
    let! complex_while = 0;
    let! w_counter = 0;
    while w_counter < 100 {
        complex_while = complex_while + 1;
        w_counter = w_counter + 1;
        if complex_while > 50 {
            break;
        }
        if w_counter % 10 == 0 {
            continue;
        }
    }

    // Loop with side effects in condition
    let! side_effect_loop = 0;
    let! condition_var = 10;
    while decrement_and_check(condition_var) {
        side_effect_loop = side_effect_loop + 1;
    }

    // Empty loop bodies
    for let! i = 0; i < 5; i = i + 1 {
        // Empty body
    }

    while false {
        // Never executes
    }

    return sum + product + nested_sum + while_sum + infinite_counter + continue_sum + deep_nested + large_loop_sum + complex_while + side_effect_loop;
}

fn decrement_and_check(n: i32): bool {
    return n > 5;  // Simplified side effect
}