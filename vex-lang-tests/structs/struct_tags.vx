// Test file for Vex structs: Struct Tags
// This file tests Go-style struct tags (backticks)

struct User {
    id: u64        `json:"id" db:"pk"`,
    username: string `json:"username" db:"username"`,
    email: string   `json:"email" db:"email"`,
    age: i32        `json:"age"`,
    is_active: bool `json:"is_active"`,
}

struct Product {
    id: u64          `json:"product_id" db:"id"`,
    name: string     `json:"product_name" db:"name" required:"true"`,
    price: f64       `json:"price" db:"price"`,
    category: string `json:"category"`,
    in_stock: bool   `json:"in_stock"`,
}

struct Configuration {
    host: string     `env:"HOST" default:"localhost"`,
    port: i32        `env:"PORT" default:"8080"`,
    debug: bool      `env:"DEBUG" default:"false"`,
    timeout: i32     `env:"TIMEOUT" default:"30"`,
}

fn main(): i32 {
    // Instantiate structs with tags
    let user = User {
        id: 12345,
        username: "johndoe",
        email: "john@example.com",
        age: 25,
        is_active: true,
    };

    let product = Product {
        id: 67890,
        name: "Widget",
        price: 29.99,
        category: "Tools",
        in_stock: true,
    };

    let config = Configuration {
        host: "api.example.com",
        port: 443,
        debug: false,
        timeout: 60,
    };

    // Access fields (tags don't affect access)
    let user_id = user.id;
    let product_price = product.price as i32;
    let config_port = config.port;

    return user_id as i32 + product_price + config_port;
}

// Edge cases for struct tags

// Test tags with special characters and complex values
struct SpecialTagsStruct {
    field1: string `json:"field_1" xml:"field-1" yaml:"fieldOne"`,
    field2: i32    `db:"field_2" index:"true" unique:"true"`,
    field3: bool   `env:"FIELD_3" default:"true" required:"false"`,
    field4: f64    `json:"field.4" db:"field__4"`,
}

fn test_special_tags(): i32 {
    let special = SpecialTagsStruct {
        field1: "test",
        field2: 42,
        field3: true,
        field4: 3.14,
    };
    
    return special.field2 + special.field4 as i32;
}

// Test tags with quotes and escaping
struct QuoteTagsStruct {
    simple: string   `json:"simple"`,
    with_quotes: string `json:"with\"quotes" db:"with'quotes"`,
    empty_value: string `json:"" db:""`,
    multi_space: string `json:"key"   db:"value"   extra:"more"`,
}

fn test_quote_tags(): i32 {
    let quoted = QuoteTagsStruct {
        simple: "simple",
        with_quotes: "with\"quotes",
        empty_value: "empty",
        multi_space: "spaced",
    };
    
    return 42;  // Just test instantiation
}

// Test very long tag values
struct LongTagsStruct {
    field: string `json:"very_long_field_name_that_might_cause_parsing_issues_or_buffer_overflows_in_some_implementations" db:"another_extremely_long_tag_value_that_tests_the_limits_of_tag_parsing" env:"VERY_LONG_ENVIRONMENT_VARIABLE_NAME_THAT_EXCEEDS_NORMAL_LIMITS"`,
}

fn test_long_tags(): i32 {
    let long = LongTagsStruct {
        field: "long tags test",
    };
    
    return 100;
}

// Test struct with mixed tagged and untagged fields
struct MixedTagsStruct {
    tagged1: i32    `json:"tagged_1"`,
    untagged1: string,
    tagged2: bool   `db:"tagged_2"`,
    untagged2: f64,
    tagged3: string `env:"tagged_3"`,
}

fn test_mixed_tags(): i32 {
    let mixed = MixedTagsStruct {
        tagged1: 1,
        untagged1: "untagged",
        tagged2: true,
        untagged2: 2.5,
        tagged3: "tagged",
    };
    
    return mixed.tagged1 + mixed.untagged2 as i32;
}

// Test empty struct with tags (edge case)
struct EmptyWithTags {
    // No fields, but could have tags if fields existed
}

fn test_empty_with_tags(): i32 {
    let empty = EmptyWithTags {};
    return 0;
}

// Test tags with unusual separators and formats
struct UnusualTagsStruct {
    field1: string `key1:value1;key2:value2`,
    field2: i32    `json:"field"db:"field"env:"FIELD"`,
    field3: bool   `single:value`,
    field4: f64    `multiple:"val1" 'val2' "val3"`,
}

fn test_unusual_tags(): i32 {
    let unusual = UnusualTagsStruct {
        field1: "unusual1",
        field2: 2,
        field3: true,
        field4: 4.0,
    };
    
    return unusual.field2 + unusual.field4 as i32;
}