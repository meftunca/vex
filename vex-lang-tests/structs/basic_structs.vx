// Test file for Vex structs: Basic Syntax and Instantiation
// This file tests basic struct definitions and instantiation

struct Point {
    x: i32,
    y: i32,
}

struct Person {
    name: string,
    age: i32,
    email: string,
}

struct Rectangle {
    width: i32,
    height: i32,
}

struct EmptyStruct {
    // No fields
}

// Nested structs (struct fields containing other structs)
struct Line {
    start: Point,
    end: Point,
}

fn main(): i32 {
    // Basic instantiation
    let p1 = Point { x: 10, y: 20 };
    let p2 = Point { x: 5, y: 15 };

    // Struct with all fields
    let person = Person {
        name: "Alice",
        age: 30,
        email: "alice@example.com",
    };

    // Partial instantiation (if supported)
    let rect = Rectangle {
        width: 100,
        height: 50,
    };

    // Empty struct - not supported, skip test
    // let empty = EmptyStruct {};

    // Access fields
    let x_sum = p1.x + p2.x;
    let total_age = person.age;
    let area = rect.width * rect.height;

    // Nested structs (using struct as field type)
    let line = Line {
        start: p1,
        end: p2,
    };

    let line_length = calculate_distance(line.start, line.end);

    return x_sum + total_age + area + line_length;
}

fn calculate_distance(p1: Point, p2: Point): i32 {
    let dx = p2.x - p1.x;
    let dy = p2.y - p1.y;
    return dx + dy;  // Simplified
}

// Edge cases for basic structs

// Test struct with many fields (stress test)
struct LargeStruct {
    f1: i32, f2: i32, f3: i32, f4: i32, f5: i32,
    f6: i32, f7: i32, f8: i32, f9: i32, f10: i32,
    f11: i32, f12: i32, f13: i32, f14: i32, f15: i32,
    _f16: i32, f17: i32, f18: i32, f19: i32, f20: i32,
}

fn test_large_struct(): i32 {
    let large = LargeStruct {
        f1: 1, f2: 2, f3: 3, f4: 4, f5: 5,
        f6: 6, f7: 7, f8: 8, f9: 9, f10: 10,
        f11: 11, f12: 12, f13: 13, f14: 14, f15: 15,
        _f16: 16, f17: 17, f18: 18, f19: 19, f20: 20,
    };
    
    return large.f1 + large.f10 + large.f20;  // 1 + 10 + 20 = 31
}

// Test struct with complex field types
struct ComplexStruct {
    point: Point,
    numbers: [i32; 5],
    name: string,
    is_active: bool,
}

fn test_complex_struct(): i32 {
    let complex = ComplexStruct {
        point: Point { x: 100, y: 200 },
        numbers: [1, 2, 3, 4, 5],
        name: "Complex",
        is_active: true,
    };
    
    return complex.point.x + complex.numbers[0] + complex.numbers[4];
}

// Test multiple instantiation of same struct
fn test_multiple_instances(): i32 {
    let p1 = Point { x: 1, y: 2 };
    let p2 = Point { x: 3, y: 4 };
    let p3 = Point { x: 5, y: 6 };
    
    return p1.x + p2.y + p3.x;  // 1 + 4 + 5 = 10
}

// Test struct field access with large values
struct BigValuesStruct {
    big_int: i64,
    small_int: i8,
}

fn test_big_values(): i64 {
    let big = BigValuesStruct {
        big_int: 9223372036854775807,  // i64 max
        small_int: 127,  // i8 max
    };
    
    return big.big_int + big.small_int as i64;
}

// Test struct with zero values
fn test_zero_values(): i32 {
    let zero_point = Point { x: 0, y: 0 };
    let zero_rect = Rectangle { width: 0, height: 0 };
    
    return zero_point.x + zero_rect.width;  // Should be 0
}

// Test deeply nested struct instantiation
struct NestedLevel1 {
    value: i32,
    inner: Point,
}

struct NestedLevel2 {
    data: NestedLevel1,
    extra: i32,
}

fn test_deep_nesting(): i32 {
    let nested = NestedLevel2 {
        data: NestedLevel1 {
            value: 42,
            inner: Point { x: 10, y: 20 },
        },
        extra: 100,
    };
    
    return nested.data.value + nested.data.inner.x + nested.extra;
}

// Test struct field access edge cases
fn test_field_access(): i32 {
    let p = Point { x: 100, y: 200 };
    
    // Chain field access
    let sum = p.x + p.y;
    
    // Access same field multiple times
    let doubled = p.x * 2 + p.y * 2;
    
    return sum + doubled;  // 300 + 600 = 900
}

// Test empty struct operations - not supported, skip
// fn test_empty_struct_operations(): i32 {
//     let e1 = EmptyStruct {};
//     let e2 = EmptyStruct {};
//     
//     // Empty structs can be assigned
//     let e3 = e1;
//     
//     return 42;  // Just return a value since empty structs have no fields
// }