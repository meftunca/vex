use vex_ast::*;
use vex_lexer::Token;

grammar;

// Operator precedence (lowest to highest)
// Left-associative for most operators

// ============================================================================
// Top Level: File -> Module -> Items
// ============================================================================

pub File: File = {
    <items:Item*> => File { items },
};

Item: Item = {
    <func:Function> => Item::Function(func),
    <s:Struct> => Item::Struct(s),
    <i:Interface> => Item::Interface(i),
    <ta:TypeAlias> => Item::TypeAlias(ta),
    <e:Enum> => Item::Enum(e),
    <c:Const> => Item::Const(c),
};

// ============================================================================
// Constants
// ============================================================================

Const: Const = {
    "const" <name:Ident> ":=" <value:Expr> ";" => Const {
        name,
        ty: None,
        value,
    },
    "const" <ty:Type> <name:Ident> "=" <value:Expr> ";" => Const {
        name,
        ty: Some(ty),
        value,
    },
};

// ============================================================================
// Enums
// ============================================================================

Enum: Enum = {
    "enum" <name:Ident> <generics:Generics?> "{" <variants:Comma<EnumVariant>> ","? "}" => Enum {
        name,
        generics: generics.unwrap_or_default(),
        variants,
    },
};

EnumVariant: EnumVariant = {
    <name:Ident> => EnumVariant {
        name,
        fields: None,
    },
    <name:Ident> "(" <fields:Comma<Type>> ")" => EnumVariant {
        name,
        fields: Some(fields),
    },
};

// ============================================================================
// Functions
// ============================================================================

Function: Function = {
    <qualifiers:FunctionQualifier*> "fn" <name:Ident> <generics:Generics?> "(" <params:Comma<Param>> ")" <return_type:("->" <Type>)?> <body:Block> => Function {
        name,
        generics: generics.unwrap_or_default(),
        params,
        return_type,
        body,
        qualifiers,
        attributes: vec![],
    },
};

FunctionQualifier: FunctionQualifier = {
    "async" => FunctionQualifier::Async,
    "gpu" => FunctionQualifier::Gpu,
};

Param: Param = {
    <name:Ident> ":" <ty:Type> => Param { name, ty },
};

// ============================================================================
// Structs & Interfaces
// ============================================================================

Struct: Struct = {
    "struct" <name:Ident> <generics:Generics?> "{" <fields:Comma<StructField>> ","? "}" => Struct {
        name,
        generics: generics.unwrap_or_default(),
        fields,
    },
};

StructField: StructField = {
    <name:Ident> ":" <ty:Type> => StructField {
        name,
        ty,
        tag: None,
    },
    <name:Ident> ":" <ty:Type> <tag:Tag> => StructField {
        name,
        ty,
        tag: Some(tag),
    },
};

Tag: String = {
    r#"`[^`]*`"# => <>.trim_matches('`').to_string(),
};

Interface: Interface = {
    "interface" <name:Ident> <generics:Generics?> "{" <methods:InterfaceMethod*> "}" => Interface {
        name,
        generics: generics.unwrap_or_default(),
        methods,
    },
};

InterfaceMethod: InterfaceMethod = {
    "fn" <name:Ident> "(" <params:Comma<Type>> ")" <return_type:("->" <Type>)?> ";" => InterfaceMethod {
        name,
        params,
        return_type,
    },
};

// ============================================================================
// Type Aliases
// ============================================================================

TypeAlias: TypeAlias = {
    "type" <name:Ident> <generics:Generics?> "=" <ty:Type> ";" => TypeAlias {
        name,
        generics: generics.unwrap_or_default(),
        ty,
    },
};

// ============================================================================
// Generics
// ============================================================================

Generics: Vec<String> = {
    "<" <params:Comma<Ident>> ">" => params,
};

// ============================================================================
// Types (simplified to avoid ambiguity)
// ============================================================================

Type: Type = {
    <t:BaseType> => t,
};

BaseType: Type = {
    <name:Ident> => Type::Primitive(name),
    <name:Ident> "<" <args:Comma<Type>> ">" => Type::Generic(name, args),
    "[" <elem:Type> ";" <size:IntLiteral> "]" => Type::Array(Box::new(elem), size as usize),
    "[" <elem:Type> "]" => Type::Slice(Box::new(elem)),
    "&" <t:BaseType> => Type::Reference(Box::new(t)),
    "*" <t:BaseType> => Type::Reference(Box::new(t)),
    "(" <t:Type> ")" => t,
};

// ============================================================================
// Statements
// ============================================================================

Block: Block = {
    "{" <stmts:Statement*> "}" => Block { statements: stmts },
};

Statement: Statement = {
    <v:VarDecl> => v,
    <e:Expr> ";" => Statement::Expression(e),
    "return" <e:Expr?> ";" => Statement::Return(e),
    <i:IfStatement> => i,
    <f:ForStatement> => f,
    <w:WhileStatement> => w,
    <s:SwitchStatement> => s,
    <b:Block> => Statement::Block(b),
    "break" ";" => Statement::Break,
    "continue" ";" => Statement::Continue,
};

VarDecl: Statement = {
    <name:Ident> ":=" <value:Expr> ";" => Statement::VarDecl {
        name,
        ty: None,
        value,
        is_mutable: true,
    },
    <ty:Type> <name:Ident> "=" <value:Expr> ";" => Statement::VarDecl {
        name,
        ty: Some(ty),
        value,
        is_mutable: true,
    },
    "const" <name:Ident> ":=" <value:Expr> ";" => Statement::VarDecl {
        name,
        ty: None,
        value,
        is_mutable: false,
    },
    "const" <ty:Type> <name:Ident> "=" <value:Expr> ";" => Statement::VarDecl {
        name,
        ty: Some(ty),
        value,
        is_mutable: false,
    },
};

IfStatement: Statement = {
    "if" <cond:Expr> <then:Block> => Statement::If {
        condition: cond,
        then_block: then,
        else_block: None,
    },
    "if" <cond:Expr> <then:Block> "else" <else_b:Block> => Statement::If {
        condition: cond,
        then_block: then,
        else_block: Some(else_b),
    },
    "if" <cond:Expr> <then:Block> "else" <else_if:IfStatement> => Statement::If {
        condition: cond,
        then_block: then,
        else_block: Some(Block { statements: vec![else_if] }),
    },
};

ForStatement: Statement = {
    "for" <init:VarDecl> <cond:Expr> ";" <post:Expr> <body:Block> => Statement::For {
        init: Some(Box::new(init)),
        condition: Some(cond),
        post: Some(post),
        body,
    },
    "for" <var:Ident> "in" <iter:Expr> <body:Block> => Statement::For {
        init: Some(Box::new(Statement::VarDecl {
            name: var.clone(),
            ty: None,
            value: iter,
            is_mutable: true,
        })),
        condition: None,
        post: None,
        body,
    },
};

WhileStatement: Statement = {
    "while" <cond:Expr> <body:Block> => Statement::While {
        condition: cond,
        body,
    },
};

SwitchStatement: Statement = {
    "switch" <expr:Expr> "{" <cases:SwitchCase*> "}" => Statement::Switch {
        expr,
        cases,
    },
};

SwitchCase: SwitchCase = {
    "case" <pattern:Expr> ":" <body:Block> => SwitchCase {
        pattern: Some(pattern),
        body,
    },
    "default" ":" <body:Block> => SwitchCase {
        pattern: None,
        body,
    },
};

// ============================================================================
// Expressions (with precedence)
// ============================================================================

pub Expr: Expression = {
    <a:AssignExpr> => a,
};

AssignExpr: Expression = {
    <left:OrExpr> "=" <right:AssignExpr> => Expression::Binary {
        op: BinaryOp::Assign,
        left: Box::new(left),
        right: Box::new(right),
    },
    <o:OrExpr> => o,
};

OrExpr: Expression = {
    <left:OrExpr> "||" <right:AndExpr> => Expression::Binary {
        op: BinaryOp::Or,
        left: Box::new(left),
        right: Box::new(right),
    },
    <a:AndExpr> => a,
};

AndExpr: Expression = {
    <left:AndExpr> "&&" <right:EqExpr> => Expression::Binary {
        op: BinaryOp::And,
        left: Box::new(left),
        right: Box::new(right),
    },
    <e:EqExpr> => e,
};

EqExpr: Expression = {
    <left:EqExpr> "==" <right:RelExpr> => Expression::Binary {
        op: BinaryOp::Eq,
        left: Box::new(left),
        right: Box::new(right),
    },
    <left:EqExpr> "!=" <right:RelExpr> => Expression::Binary {
        op: BinaryOp::Ne,
        left: Box::new(left),
        right: Box::new(right),
    },
    <r:RelExpr> => r,
};

RelExpr: Expression = {
    <left:RelExpr> "<" <right:AddExpr> => Expression::Binary {
        op: BinaryOp::Lt,
        left: Box::new(left),
        right: Box::new(right),
    },
    <left:RelExpr> "<=" <right:AddExpr> => Expression::Binary {
        op: BinaryOp::Le,
        left: Box::new(left),
        right: Box::new(right),
    },
    <left:RelExpr> ">" <right:AddExpr> => Expression::Binary {
        op: BinaryOp::Gt,
        left: Box::new(left),
        right: Box::new(right),
    },
    <left:RelExpr> ">=" <right:AddExpr> => Expression::Binary {
        op: BinaryOp::Ge,
        left: Box::new(left),
        right: Box::new(right),
    },
    <a:AddExpr> => a,
};

AddExpr: Expression = {
    <left:AddExpr> "+" <right:MulExpr> => Expression::Binary {
        op: BinaryOp::Add,
        left: Box::new(left),
        right: Box::new(right),
    },
    <left:AddExpr> "-" <right:MulExpr> => Expression::Binary {
        op: BinaryOp::Sub,
        left: Box::new(left),
        right: Box::new(right),
    },
    <m:MulExpr> => m,
};

MulExpr: Expression = {
    <left:MulExpr> "*" <right:UnaryExpr> => Expression::Binary {
        op: BinaryOp::Mul,
        left: Box::new(left),
        right: Box::new(right),
    },
    <left:MulExpr> "/" <right:UnaryExpr> => Expression::Binary {
        op: BinaryOp::Div,
        left: Box::new(left),
        right: Box::new(right),
    },
    <left:MulExpr> "%" <right:UnaryExpr> => Expression::Binary {
        op: BinaryOp::Mod,
        left: Box::new(left),
        right: Box::new(right),
    },
    <u:UnaryExpr> => u,
};

UnaryExpr: Expression = {
    "-" <e:UnaryExpr> => Expression::Unary {
        op: UnaryOp::Neg,
        expr: Box::new(e),
    },
    "!" <e:UnaryExpr> => Expression::Unary {
        op: UnaryOp::Not,
        expr: Box::new(e),
    },
    "&" <e:UnaryExpr> => Expression::Unary {
        op: UnaryOp::Ref,
        expr: Box::new(e),
    },
    "*" <e:UnaryExpr> => Expression::Unary {
        op: UnaryOp::Deref,
        expr: Box::new(e),
    },
    <p:PostfixExpr> => p,
};

PostfixExpr: Expression = {
    <base:PostfixExpr> "(" <args:Comma<Expr>> ")" => Expression::Call {
        func: Box::new(base),
        args,
    },
    <base:PostfixExpr> "[" <index:Expr> "]" => Expression::Index {
        base: Box::new(base),
        index: Box::new(index),
    },
    <base:PostfixExpr> "." <field:Ident> => Expression::FieldAccess {
        base: Box::new(base),
        field,
    },
    <base:PostfixExpr> "++" => Expression::PostfixOp {
        expr: Box::new(base),
        op: PostfixOp::Increment,
    },
    <base:PostfixExpr> "--" => Expression::PostfixOp {
        expr: Box::new(base),
        op: PostfixOp::Decrement,
    },
    <p:PrimaryExpr> => p,
};

PrimaryExpr: Expression = {
    <i:IntLiteral> => Expression::IntLiteral(i),
    <f:FloatLiteral> => Expression::FloatLiteral(f),
    <s:StringLiteral> => Expression::StringLiteral(s),
    <b:BoolLiteral> => Expression::BoolLiteral(b),
    <id:Ident> => Expression::Identifier(id),
    "(" <e:Expr> ")" => e,
    <s:StructLiteral> => s,
    <a:ArrayLiteral> => a,
    "new" "(" <e:Expr> ")" => Expression::New(Box::new(e)),
    "make" "(" "[" <ty:Type> "]" "," <size:Expr> ")" => Expression::Make {
        ty,
        size: Box::new(size),
    },
    "await" <e:PrimaryExpr> => Expression::Await(Box::new(e)),
    "go" <e:PrimaryExpr> => Expression::Go(Box::new(e)),
};

StructLiteral: Expression = {
    <name:Ident> "{" <fields:Comma<FieldInit>> ","? "}" => Expression::StructLiteral {
        name,
        fields,
    },
};

FieldInit: (String, Expression) = {
    <name:Ident> ":" <value:Expr> => (name, value),
};

ArrayLiteral: Expression = {
    "[" <elements:Comma<Expr>> "]" => Expression::ArrayLiteral(elements),
};

// ============================================================================
// Terminals (Lexer Tokens)
// ============================================================================

Ident: String = {
    r"[a-zA-Z_][a-zA-Z0-9_]*" => <>.to_string(),
};

IntLiteral: i64 = {
    r"[0-9]+" => <>.parse().unwrap(),
    r"0x[0-9a-fA-F]+" => i64::from_str_radix(&<>[2..], 16).unwrap(),
};

FloatLiteral: f64 = {
    r"[0-9]+\.[0-9]+" => <>.parse().unwrap(),
};

StringLiteral: String = {
    r#""([^"\\]|\\.)*""# => {
        let s = <>;
        s[1..s.len()-1].to_string()
    },
};

BoolLiteral: bool = {
    "true" => true,
    "false" => false,
};

// ============================================================================
// Utilities
// ============================================================================

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => {
        if let Some(e) = e {
            v.push(e);
        }
        v
    }
};
