# Closure Traits in Vex

## Overview

Vex uses three traits to represent different closure behaviors, similar to Rust's `Fn`, `FnMut`, and `FnOnce`, but with cleaner, Vex-native syntax.

## The Three Traits

### 1. **Callable** - Immutable Capture (Most Restrictive)

**Vex Name:** `Callable<Args, Return>`  
**Rust Equivalent:** `Fn`  
**Capture:** Immutable references (`&T`)

```vex
let x = 10;
let read_x = |y: i32| x + y;  // Captures x by immutable reference

// Can be called multiple times
let result1 = read_x(5);   // 15
let result2 = read_x(10);  // 20
// x is still usable here
```

**Properties:**

- ‚úÖ Can be called multiple times
- ‚úÖ Captured variables remain unchanged
- ‚úÖ Most flexible for consumers (can be passed to any function expecting closures)
- ‚ùå Cannot modify captured variables

**Trait Definition:**

```vex
trait Callable<Args, Return>: CallableMut<Args, Return> {
    fn call(self: &Self, args: Args): Return;
}
```

### 2. **CallableMut** - Mutable Capture (Medium Restrictive)

**Vex Name:** `CallableMut<Args, Return>`  
**Rust Equivalent:** `FnMut`  
**Capture:** Mutable references (`&T!`)

```vex
let! counter = 0;
let increment = |x: i32| {
    counter = counter + 1;  // Modifies captured variable
    return counter + x;
};

let result1 = increment(5);   // counter=1, returns 6
let result2 = increment(10);  // counter=2, returns 12
```

**Properties:**

- ‚úÖ Can be called multiple times
- ‚úÖ Can modify captured variables
- ‚ö†Ô∏è Requires mutable access to closure (`&closure!`)
- ‚ùå Less flexible than `Callable`

**Trait Definition:**

```vex
trait CallableMut<Args, Return>: CallableOnce<Args, Return> {
    fn call_mut(self: &Self!, args: Args): Return;
}
```

### 3. **CallableOnce** - Move Capture (Least Restrictive)

**Vex Name:** `CallableOnce<Args, Return>`  
**Rust Equivalent:** `FnOnce`  
**Capture:** Ownership (move semantics)

```vex
let data = vec![1, 2, 3];
let consume = || {
    process(data);  // Takes ownership of data
};

consume();  // ‚úÖ First call - data is moved
consume();  // ‚ùå ERROR: data already moved, closure consumed
```

**Properties:**

- ‚ö†Ô∏è Can only be called once
- ‚úÖ Can take ownership of captured variables
- ‚úÖ Most flexible for closure definition
- ‚ùå Most restrictive for consumers

**Trait Definition:**

```vex
trait CallableOnce<Args, Return> {
    fn call_once(self: Self, args: Args): Return;
}
```

## Trait Hierarchy

```
CallableOnce  (most permissive)
    ‚Üë
CallableMut   (middle ground)
    ‚Üë
Callable      (most restrictive)
```

Every `Callable` is also a `CallableMut`, and every `CallableMut` is also a `CallableOnce`.

## Automatic Trait Implementation

The compiler automatically determines which trait a closure implements based on how it captures variables:

```vex
// Case 1: No captures ‚Üí Callable
let pure = |x: i32| x * 2;
// Implements: Callable, CallableMut, CallableOnce

// Case 2: Immutable captures ‚Üí Callable
let y = 10;
let add_y = |x: i32| x + y;
// Implements: Callable, CallableMut, CallableOnce

// Case 3: Mutable captures ‚Üí CallableMut
let! counter = 0;
let count = || { counter = counter + 1; };
// Implements: CallableMut, CallableOnce

// Case 4: Move captures ‚Üí CallableOnce
let data = vec![1, 2, 3];
let consume = move || process(data);
// Implements: CallableOnce only
```

## Usage in Generic Functions

### Example 1: Map (Callable)

```vex
// Generic function with closure trait bound
fn map<T, U, F: Callable(T): U>(items: [T], func: F): [U] {
    let! result = [];
    for item in items {
        result.push(func.call(item));
    }
    return result;
}

// Usage with lambda
let numbers = [1, 2, 3];
let doubled = map(numbers, |x: i32| x * 2);
// [2, 4, 6]

// Usage with explicit struct (Vex-style trait impl)
struct Doubler impl Callable(i32): i32 {
    // Trait methods auto-generated by compiler
}

let doubler = Doubler{};
let doubled2 = map(numbers, doubler);
```

### Example 2: Fold (CallableMut)

```vex
fn fold<T, U, F: CallableMut(U, T): U>(items: [T], init: U, func: F): U {
    let! acc = init;
    for item in items {
        acc = func.call_mut(acc, item);
    }
    return acc;
}

let numbers = [1, 2, 3];
let sum = fold(numbers, 0, |acc: i32, x: i32| acc + x);
// 6
```

### Example 3: Thread Spawn (CallableOnce)

```vex
fn spawn<F: CallableOnce(): void>(task: F) {
    // task takes ownership and is consumed
    task.call_once();
}

let data = vec![1, 2, 3];
spawn(move || {
    process(data);  // data moved into closure
});
```

## Vex Trait Implementation Syntax

**Important:** Vex uses `impl` keyword differently than Rust!

### Rust Style (NOT VEX):

```rust
// ‚ùå This is Rust, not Vex
impl Callable(i32): i32 for MyStruct {
    fn call(&self, x: i32) -> i32 { ... }
}
```

### Vex Style (CORRECT):

```vex
// ‚úÖ Vex syntax: struct declares trait implementation
struct MyStruct impl Callable(i32): i32 {
    // Fields here
    captured_value: i32,
}

// Compiler auto-generates trait methods:
// - call(&Self, i32): i32
// Trait methods can access struct fields
```

### How Vex Trait Impl Works

1. **Declaration:** `struct Name impl Trait { fields }`
2. **Compiler generates:** All trait methods automatically
3. **Trait methods:** Can access struct fields via `self`

Example:

```vex
// Trait definition
trait Callable(i32): i32 {
    fn call(self: &Self, arg: i32): i32;
}

// User writes:
let x = 10;
let adder = |y: i32| x + y;

// Compiler generates (conceptually):
struct __Closure_1 impl Callable(i32): i32 {
    captured_x: i32,
}

// Method auto-generated:
// fn call(self: &__Closure_1, arg: i32): i32 {
//     return self.captured_x + arg;
// }
```

## Syntax Differences from Rust

| Feature               | Rust                      | Vex                                       |
| --------------------- | ------------------------- | ----------------------------------------- |
| Trait names           | `Fn`, `FnMut`, `FnOnce`   | `Callable`, `CallableMut`, `CallableOnce` |
| Mutable reference     | `&mut T`                  | `&T!`                                     |
| Trait bounds          | `F: Fn(i32) -> i32`       | `F: Callable(i32): i32`                   |
| Return type separator | `->`                      | `:`                                       |
| Trait impl            | `impl Trait for Type { }` | `struct Type impl Trait { }`              |
| Trait methods         | Manual implementation     | Auto-generated by compiler                |
| Generic function      | `fn map<F: Fn(T) -> U>`   | `fn map<F: Callable(T): U>`               |
| Trait objects         | `Box<dyn Fn()>`           | Not needed (simpler syntax)               |
| Move closure          | `move \|\| ...`           | `move \|\| ...` (same)                    |

**Key Difference:** Vex's `impl` keyword is a **binding operator** between struct and trait, not a separate block. The compiler generates all trait methods automatically based on the struct's fields and the closure body.

## Type Inference

The compiler infers closure traits automatically:

```vex
fn process<F>(f: F) where F: Callable(i32): i32 {
    let result = f.call(42);
}

let x = 10;
process(|y: i32| x + y);  // ‚úÖ Inferred as Callable
```

## Common Patterns

### Pattern 1: Iterator Methods

```vex
trait Iterator<T> {
    fn map<U, F: Callable(T): U>(self: Self, f: F): MapIterator<Self, F>;
    fn filter<F: Callable(T): bool>(self: Self, f: F): FilterIterator<Self, F>;
    fn fold<U, F: CallableMut(U, T): U>(self: Self, init: U, f: F): U;
}
```

### Pattern 2: Event Handlers

```vex
struct Button {
    on_click: fn(): void,  // Simple function pointer (no captures)
}

// Or with mutable state:
struct Counter {
    on_increment: fn(&Self!): void,  // Closure with mutable access
}
```

### Pattern 3: Lazy Evaluation

```vex
struct Lazy<T, F: CallableOnce(): T> {
    func: F?,
    value: T?,

    fn get(self: &Self!): T {
        if self.value is None {
            self.value = Some(self.func!.call_once());
        }
        return self.value!;
    }
}
```

## Implementation Status

- ‚úÖ Basic closure syntax
- ‚úÖ Environment capture (immutable)
- ‚úÖ Environment binding at call site
- üöß Trait definitions (in progress)
- ‚è≥ Mutable capture analysis
- ‚è≥ Move semantics detection
- ‚è≥ Generic constraint checking

## Next Steps

1. Implement capture mode analysis in borrow checker
2. Add trait bounds to type system
3. Generate trait method implementations during codegen
4. Add tests for all three trait types
